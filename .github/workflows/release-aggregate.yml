name: release-aggregate (dynamic execution)

on:
  push:
    branches: [ "main" ]
    paths:
      - "*"
      - "!README*"
      - "!LICENSE*"
      - "!.github/**"
      - "!templates/**"
      - "!tools/**"
  workflow_dispatch:
    inputs:
      scope:
        description: "Scope of scripts to process (auto=changed only, all=all scripts, none=no scripts, list=explicit list)"
        type: choice
        default: auto
        options:
          - auto
          - all
          - none
          - list
      scripts:
        description: "Comma-separated list of scripts (only if scope=list)"
        required: false
        type: string

permissions:
  contents: write

concurrency:
  group: release-aggregate
  cancel-in-progress: false

jobs:
  build-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set timezone (Europe/Brussels)
        run: sudo timedatectl set-timezone Europe/Brussels

      - name: Prepare environment
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl coreutils

      - name: Aggregate & publish release (inline)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RETAIN: "5"
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          die(){ echo "✖ $*" >&2; exit 1; }
          log(){ echo "• $*"; }

          OWNER_REPO="$(git config --get remote.origin.url | sed -E 's#.*github.com[:/](.+/.+)(\.git)?#\1#')"
          [ -n "${OWNER_REPO:-}" ] || die "Cannot determine owner/repo"

          # Scope
          SCOPE="${{ github.event.inputs.scope || 'auto' }}"
          SCRIPTS_INPUT="${{ github.event.inputs.scripts || '' }}"
          log "Run scope: $SCOPE"

          # Catalogue complet
          mapfile -t ALL_SCRIPTS < <(
            git ls-files \
              | grep -v -E '^(.github/|templates/|tools/|README|LICENSE)' \
              | grep -v -E '\.sha256$' \
              | while read -r f; do
                  [ -f "$f" ] || continue
                  head -n1 "$f" | grep -q '^#!' || continue
                  grep -q -m1 -E '^#\s*VERSION=' "$f" || continue
                  echo "$f"
                done
          )
          [ ${#ALL_SCRIPTS[@]} -gt 0 ] || die "No scripts detected."

          # Fichiers modifiés
          mapfile -t CHANGED_FILES < <(
            if [ "${{ github.event_name }}" = "push" ]; then
              git diff --name-only "${{ github.event.before }}" HEAD
            else
              git diff --name-only HEAD^ HEAD
            fi
          )
          declare -A changedSet=()
          for f in "${CHANGED_FILES[@]}"; do changedSet["$f"]=1; done

          # Scripts sélectionnés
          SCRIPTS=()
          case "$SCOPE" in
            none) log "Manual run scope=none → no scripts will be processed." ;;
            all)  SCRIPTS=("${ALL_SCRIPTS[@]}") ;;
            auto) for f in "${ALL_SCRIPTS[@]}"; do [[ -n "${changedSet[$f]:-}" ]] && SCRIPTS+=("$f"); done ;;
            list)
              IFS=',' read -ra wanted <<<"$SCRIPTS_INPUT"
              for w in "${wanted[@]}"; do
                w="$(echo "$w" | xargs)"
                [ -n "$w" ] || continue
                if [[ " ${ALL_SCRIPTS[*]} " == *" $w "* ]]; then
                  SCRIPTS+=("$w")
                else
                  log "⚠ Script '$w' not found in repo"
                fi
              done ;;
            *) die "Unknown scope: $SCOPE" ;;
          esac

          log "Changed files:"
          printf '%s\n' "${CHANGED_FILES[@]}" || true
          log "Scripts à exécuter (Docker):"
          printf '%s\n' "${SCRIPTS[@]}" || true

          # Garde-fou
          if [ ${#SCRIPTS[@]} -eq 0 ]; then
            log "No scripts selected (scope=$SCOPE) → skipping release creation to preserve existing 'latest'."
            exit 0
          fi

          # Notes
          NOTES="$(mktemp)"
          {
            echo "## Scripts et versions"
            echo
            echo "| Script | Version |"
            echo "|-------:|:--------|"
            for f in "${ALL_SCRIPTS[@]}"; do
              name="$(basename "$f")"
              ver="$(grep -m1 -E '^#\s*VERSION=' "$f" | sed -E 's/^#\s*VERSION=//')"
              [ -n "$ver" ] || ver="inconnue"
              printf "| \`%s\` | \`%s\` |\n" "$name" "$ver"
            done
          } > "$NOTES"

          # Assets à publier (TOUS les scripts)
          FILES_TO_UPLOAD=()
          for f in "${ALL_SCRIPTS[@]}"; do
            name="$(basename "$f")"
            if command -v sha256sum >/dev/null 2>&1; then
              hash="$(sha256sum "$f" | awk '{print tolower($1)}')"
            else
              hash="$(shasum -a 256 "$f" | awk '{print $1}')"
            fi
            printf "%s  %s\n" "$hash" "$name" > "$f.sha256"
            FILES_TO_UPLOAD+=( "$f" "$f.sha256" )
          done

          # Tag & titre
          year=$(date +%Y); month=$(date +%m); day=$(date +%d)
          hour=$(date +%H);  min=$(date +%M)
          moisNoms=( "" "janvier" "février" "mars" "avril" "mai" "juin" "juillet" "août" "septembre" "octobre" "novembre" "décembre" )
          moisIdx=$((10#$month))
          date_fr="${day} ${moisNoms[$moisIdx]} ${year} ${hour}h${min}"
          TAG="r-${year}-${month}-${day}-${hour}${min}"
          TITLE="Mes scripts au ${date_fr}"

          echo -e "\n---"
          echo "Tag      : $TAG"
          echo "Titre    : $TITLE"
          echo "Repo     : $OWNER_REPO"
          echo "Scripts exécutés : ${#SCRIPTS[@]}"
          echo "Scripts publiés  : ${#ALL_SCRIPTS[@]}"
          echo "---"

          command -v gh >/dev/null 2>&1 || die "GitHub CLI required"

          if gh release view "$TAG" >/dev/null 2>&1; then
            log "Tag $TAG already exists – deleting release and tag"
            gh release delete "$TAG" -y || true
            git push origin ":refs/tags/$TAG" || true
          fi

          # Publication
          gh release create "$TAG" \
            --title "$TITLE" \
            --notes-file "$NOTES" \
            --latest \
            "${FILES_TO_UPLOAD[@]}"

          log "Release $TAG published with ${#FILES_TO_UPLOAD[@]} assets."

          # Prune anciennes releases
          RETAIN="${RETAIN:-5}"
          log "Pruning releases beyond the most recent ${RETAIN}…"
          gh api -H "Accept: application/vnd.github+json" "/repos/${OWNER_REPO}/releases?per_page=100" \
            | jq -r '.[].tag_name' | awk 'NF' | nl -ba \
            | while read -r idx tag; do
                if [ "$idx" -gt "$RETAIN" ]; then
                  log "  - deleting $tag"
                  gh release delete "$tag" -y || true
                  git push origin ":refs/tags/$tag" || true
                fi
              done

          log "Done."

          # ---- Docker EXÉCUTION (logs visibles) ----
          for f in "${SCRIPTS[@]}"; do
            name="$(basename "$f")"
            echo ">>> Running Docker sandbox for $name"
            docker run --rm --network none -v "$PWD":/work -w /work --memory=256m --cpus=0.5 \
              ubuntu:22.04 bash -lc "\
                set -e; \
                apt-get update -qq >/dev/null 2>&1 || true; \
                apt-get install -y -qq bash coreutils >/dev/null 2>&1 || true; \
                ( timeout 6s bash /work/$f --version 2>&1 || timeout 6s bash /work/$f -V 2>&1 || true ) > /work/${f}.version.txt 2>&1 || true; \
                ( timeout 8s bash /work/$f -h 2>&1 || timeout 8s bash /work/$f --help 2>&1 || true ) > /work/${f}.help.txt 2>&1 || true" || true
          done

          # ---- Sanity check avec retries ----
          SRC_REPO="$OWNER_REPO"
          for f in "${ALL_SCRIPTS[@]}"; do
            name="$(basename "$f")"
            for ext in "" ".sha256"; do
              url="https://github.com/${SRC_REPO}/releases/latest/download/${name}${ext}"
              code=""
              for i in $(seq 1 6); do
                code="$(curl -sS -o /dev/null -w '%{http_code}' -L "$url" || echo 000)"
                [ "$code" = "200" ] || [ "$code" = "302" ] || [ "$code" = "206" ] && break
                sleep 2
              done
              echo "$code $url"
              if [ "$code" != "200" ] && [ "$code" != "302" ] && [ "$code" != "206" ]; then
                echo "::warning ::Lien invalide (après retries): $url (HTTP $code)"
              fi
            done
          done
