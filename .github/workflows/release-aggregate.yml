name: Sync mes-scripts pages (multi-branch, overwrite with static asset links)

on:
  repository_dispatch:
    types: [mes-scripts-release]
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branche d'écriture (optionnel, sinon TARGET_BRANCH ou default)"
        required: false
        default: ""

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    env:
      # Définir TARGET_BRANCH dans: Settings → Security → Secrets and variables → Actions → Variables
      # ex: feature/menu-outils-structure
      TARGET_BRANCH: ${{ vars.TARGET_BRANCH }}

    steps:
      - name: Compute target branch
        id: branch
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const inputBranch = (core.getInput('target_branch') || '').trim();
            const varBranch   = (process.env.TARGET_BRANCH || '').trim();

            const repoInfo = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.data.default_branch || 'master';

            const targetBranch = inputBranch || varBranch || defaultBranch;
            core.setOutput('target', targetBranch);
            core.info(`Target branch: ${targetBranch}`);

      - name: Overwrite bundles from payload (no checkout)
        uses: actions/github-script@v7
        with:
          script: |
            const siteOwner = context.repo.owner;
            const siteRepo  = context.repo.repo;
            const targetBranch = '${{ steps.branch.outputs.target }}';

            // Payload reçu de mes-scripts
            const payload     = context.payload.client_payload || {};
            const scripts     = Array.isArray(payload.scripts) ? payload.scripts : [];
            const assets      = payload.assets || {};                // { script: {url, sha256, version} }
            const tag         = payload.release_tag || "unknown-tag";
            const sourceRepo  = payload.source_repo || "NoelNac-HackEthical/mes-scripts"; // owner/repo

            if (context.eventName !== 'workflow_dispatch' && scripts.length === 0) {
              core.warning("Payload.scripts est vide — rien à synchroniser.");
              return;
            }

            // Helpers ---------------------------------------------------------
            async function getRefSha(branch) {
              const res = await github.rest.git.getRef({ owner: siteOwner, repo: siteRepo, ref: `heads/${branch}` }).catch(() => null);
              return res?.data?.object?.sha || null;
            }
            async function getFileSha(path) {
              try {
                const res = await github.rest.repos.getContent({ owner: siteOwner, repo: siteRepo, path, ref: targetBranch });
                if (Array.isArray(res.data)) return null;
                return res.data.sha || null;
              } catch { return null; }
            }
            async function upsertFile(path, content, message) {
              const sha = await getFileSha(path);
              const encoded = Buffer.from(content, "utf8").toString("base64");
              await github.rest.repos.createOrUpdateFileContents({
                owner: siteOwner, repo: siteRepo, path, message, content: encoded,
                sha: sha || undefined, branch: targetBranch
              });
            }
            async function deleteFile(path, message) {
              const res = await github.rest.repos.getContent({ owner: siteOwner, repo: siteRepo, path, ref: targetBranch }).catch(() => null);
              const sha = res && !Array.isArray(res.data) ? res.data.sha : null;
              if (!sha) return;
              await github.rest.repos.deleteFile({ owner: siteOwner, repo: siteRepo, path, message, sha, branch: targetBranch });
            }

            // Mise en forme du titre (Mon Nmap, Mon Recoweb, ...)
            function toTitle(name) {
              return name
                .replace(/[-_]+/g, ' ')
                .split(' ')
                .map(w => w ? (w[0].toUpperCase() + w.slice(1)) : w)
                .join(' ');
            }

            // Template index.md (front matter visuel + liens latest + version script + lien repo)
            function renderIndexMinimal(name, assetsMap, tag, sourceRepo) {
              const a   = assetsMap && assetsMap[name] ? assetsMap[name] : {};
              const ver = a.version || "unknown";

              const [owner, repo] = (sourceRepo.includes('/') ? sourceRepo.split('/') : ["NoelNac-HackEthical","mes-scripts"]);
              const latestBase = `https://github.com/${owner}/${repo}/releases/latest/download`;
              const latestUrl  = `${latestBase}/${name}`;
              const latestSha  = `${latestBase}/${name}.sha256`;
              const repoUrl    = `https://github.com/${owner}/${repo}`;

              const title = toTitle(name);
              const slug  = name; // slug = nom du script tel quel

              // FRONT MATTER EXACTEMENT SELON TON MODÈLE
              const frontMatter = [
                '---',
                `title: "${title}"`,
                `slug: "${slug}"`,
                `description: "Résumé court de l'outil."`,
                'draft: false',
                'tags: ["scripts","tools"]',
                'categories: ["Mes scripts"]',
                'showIntro: false',
                'cover:',
                '  hidden: true',
                '  hiddenInSingle: true',
                `repo: "${sourceRepo}"`,
                '---'
              ].join('\n');

              const body = [
                '',
                '## Télécharger le script',
                '',
                `<p class="version-line">`,
                `  La version courante du script est <code>${ver}</code>`,
                `</p>`,
                '',
                `<div class="dl-row">`,
                `  <a href="${latestUrl}" class="he-btn he-btn--neutral">Télécharger la version courante</a>`,
                `  <a href="${latestSha}" class="he-btn he-btn--sm he-btn--neutral">SHA256</a>`,
                `</div>`,
                '',
                `<p><a href="${repoUrl}">Voir le dépôt mes-scripts sur GitHub</a></p>`,
                '',
                "> Cette page est générée automatiquement à partir des releases de **mes-scripts** (liens par défaut vers `latest`).",
                ''
              ].join('\n');

              return frontMatter + '\n' + body;
            }

            // 1) Vérifier la branche cible
            const targetSha = await getRefSha(targetBranch);
            if (!targetSha) {
              core.setFailed(`Branche cible introuvable: ${targetBranch}`);
              return;
            }

            // 2) Lister les index.md existants
            const tree = await github.rest.git.getTree({ owner: siteOwner, repo: siteRepo, tree_sha: targetSha, recursive: "1" });
            const existingFiles = new Set();
            for (const item of tree.data.tree) {
              if (item.type === "blob" && item.path.startsWith("content/mes-scripts/") && item.path.endsWith("/index.md")) {
                existingFiles.add(item.path);
              }
            }

            // 3) Exécution manuelle sans payload -> log et stop
            if (scripts.length === 0) {
              core.info(`Aucun script dans le payload. Test manuel OK sur ${targetBranch}.`);
              return;
            }

            // 4) Écrire/écraser les pages
            for (const s of scripts) {
              const path = `content/mes-scripts/${s}/index.md`;
              const body = renderIndexMinimal(s, assets, tag, sourceRepo);
              const msg  = `chore(mes-scripts): overwrite ${path} from ${tag} [branch=${targetBranch}]`;
              await upsertFile(path, body, msg);
              core.info(`[UPSERT] ${path}`);
            }

            // 5) Supprimer ce qui n'est plus listé
            const desiredSet = new Set(scripts);
            const toDelete = [...existingFiles].filter(p => {
              const parts = p.split('/');
              const scriptName = parts[2];
              return !desiredSet.has(scriptName);
            });
            for (const path of toDelete) {
              const msg = `chore(mes-scripts): remove ${path} (not in ${tag}) [branch=${targetBranch}]`;
              await deleteFile(path, msg);
              core.info(`[DELETE] ${path}`);
            }

            core.info(`Sync terminé sur ${targetBranch} — ${scripts.length} script(s).`);
