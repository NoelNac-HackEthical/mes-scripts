name: release-aggregate (dynamic execution)

on:
  push:
    branches: [ "main" ]
    paths:
      - "*"
      - "!README*"
      - "!LICENSE*"
      - "!.github/**"
      - "!templates/**"
      - "!tools/**"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: release-aggregate
  cancel-in-progress: false

jobs:
  build-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set timezone (Europe/Brussels)
        run: sudo timedatectl set-timezone Europe/Brussels

      - name: Prepare environment
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl coreutils

      # ------------------------------------------------------------------
      # NEW : Détection des scripts modifiés (généralisation root/*.*)
      # ------------------------------------------------------------------
      - name: Detect changed scripts (root/*.* only)
        id: detect_changed
        shell: bash
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          # Base pour le diff (dernier commit commun avec origin/main si dispo)
          git fetch origin main --depth=2 || true
          base="$(git merge-base HEAD origin/main || git rev-parse HEAD^ || true)"

          # Candidats = fichiers à la racine (quel que soit le nom), hors exclusions
          mapfile -t CANDIDATES < <(
            git ls-files \
              | grep -v -E '^(.github/|templates/|tools/)' \
              | grep -v -E '^(README|LICENSE)' \
              | grep -v -E '\.sha256$' \
              | awk -F/ 'NF==1'
          )

          # Heuristique "script mes-scripts" : shebang + ligne '# VERSION='
          SCRIPTS=()
          for f in "${CANDIDATES[@]}"; do
            [ -f "$f" ] || continue
            head -n1 "$f" | grep -q '^#!' || continue
            grep -q -m1 -E '^#\s*VERSION=' "$f" || continue
            SCRIPTS+=( "$f" )
          done

          # Liste des fichiers modifiés dans ce push
          changed_files="$(git diff --name-only ${base:+$base} HEAD || true)"

          : > .changed.list
          for f in "${SCRIPTS[@]}"; do
            if grep -qx "$f" <<< "$changed_files"; then
              echo "$f" >> .changed.list
            fi
          done

          echo "Changed scripts:"
          cat .changed.list || true

      # Agrégation / publication de la release (inline) — inchangé
      - name: Aggregate & publish release (inline)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RETAIN: "5"
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          die(){ echo "✖ $*" >&2; exit 1; }
          log(){ echo "• $*"; }

          OWNER_REPO="$(git config --get remote.origin.url | sed -E 's#.*github.com[:/](.+/.+)(\.git)?#\1#')"
          [ -n "${OWNER_REPO:-}" ] || die "Cannot determine owner/repo"

          mapfile -t SCRIPTS < <(
            git ls-files \
              | grep -v -E '^(.github/|templates/|tools/|README|LICENSE)' \
              | grep -v -E '\.sha256$' \
              | while read -r f; do
                  [ -f "$f" ] || continue
                  head -n1 "$f" | grep -q '^#!' || continue
                  grep -q -m1 -E '^#\s*VERSION=' "$f" || continue
                  echo "$f"
                done
          )

          [ ${#SCRIPTS[@]} -gt 0 ] || die "No scripts detected (missing '# VERSION=' lines?)"

          NOTES="$(mktemp)"
          FILES_TO_UPLOAD=()

          {
            echo "## Scripts et versions"
            echo
            echo "| Script | Version |"
            echo "|-------:|:--------|"
          } > "$NOTES"

          for f in "${SCRIPTS[@]}"; do
            name="$(basename "$f")"
            ver="$(grep -m1 -E '^#\s*VERSION=' "$f" | sed -E 's/^#\s*VERSION=//')"
            [ -n "$ver" ] || ver="inconnue"

            if command -v sha256sum >/dev/null 2>&1; then
              hash="$(sha256sum "$f" | awk '{print tolower($1)}')"
            elif command -v shasum >/dev/null 2>&1; then
              hash="$(shasum -a 256 "$f" | awk '{print $1}')"
            else
              hash="unknown"
            fi

            printf "%s  %s\n" "$hash" "$name" > "$f.sha256"
            FILES_TO_UPLOAD+=( "$f" "$f.sha256" )
            printf "| \`%s\` | \`%s\` |\n" "$name" "$ver" >> "$NOTES"
          done

          year=$(date +%Y); month=$(date +%m); day=$(date +%d)
          hour=$(date +%H);  min=$(date +%M)
          moisNoms=( "" "janvier" "février" "mars" "avril" "mai" "juin" "juillet" "août" "septembre" "octobre" "novembre" "décembre" )
          moisIdx=$((10#$month))
          date_fr="${day} ${moisNoms[$moisIdx]} ${year} ${hour}h${min}"

          TAG="r-${year}-${month}-${day}-${hour}${min}"
          TITLE="Mes scripts au ${date_fr}"

          echo -e "\n---"
          echo "Tag      : $TAG"
          echo "Titre    : $TITLE"
          echo "Repo     : $OWNER_REPO"
          echo "Scripts  : ${#SCRIPTS[@]}"
          echo "---"

          if ! command -v gh >/dev/null 2>&1; then
            die "GitHub CLI (gh) is required on the runner"
          fi

          if gh release view "$TAG" >/dev/null 2>&1; then
            log "Tag $TAG already exists – deleting release and tag"
            gh release delete "$TAG" -y || true
            git push origin ":refs/tags/$TAG" || true
          fi

          gh release create "$TAG" \
            --title "$TITLE" \
            --notes-file "$NOTES" \
            --latest \
            "${FILES_TO_UPLOAD[@]}"

          log "Release $TAG published with ${#FILES_TO_UPLOAD[@]} assets."

          RETAIN="${RETAIN:-5}"
          log "Pruning releases beyond the most recent ${RETAIN}…"

          gh api -H "Accept: application/vnd.github+json" "/repos/${OWNER_REPO}/releases?per_page=100" \
            | jq -r '.[].tag_name' | awk 'NF' | nl -ba \
            | while read -r idx tag; do
                if [ "$idx" -gt "$RETAIN" ]; then
                  log "  - deleting $tag"
                  gh release delete "$tag" -y || true
                  git push origin ":refs/tags/$tag" || true
                fi
              done

          log "Done."

      # Construction du payload pour hugo-demo (Dynamic execution + 'v' 1re ligne) — MODIFIÉ (filtrage)
      - name: Build payload for hugo site (dynamic execution)
        id: build_payload
        shell: bash
        run: |
          set -euo pipefail
          IFS=$'\n\t'

          REPO="${{ github.repository }}"
          API="https://api.github.com/repos/${REPO}/releases/latest"

          JSON="$(curl -sSL -H "Accept: application/vnd.github+json" "$API")"
          TAG="$(echo "$JSON" | jq -r '.tag_name')"

          # Assets (name + url)
          ASSETS_JSON="$(echo "$JSON" | jq -c '[.assets[] | {name: .name, url: .browser_download_url}]')"

          # Liste des scripts (sans les .sha256)
          SCRIPTS_JSON="$(echo "$ASSETS_JSON" | jq -r '[.[].name] | map(select(test("\\.sha256$")|not))')"

          # --- NEW: Ne garder QUE les scripts réellement modifiés dans ce push ---
          if [ -s .changed.list ]; then
            CHANGED_JSON="$(jq -R -s -c 'split("\n")|map(select(length>0))' .changed.list)"
            SCRIPTS_JSON="$(
              jq -n --argjson all "$SCRIPTS_JSON" --argjson ch "$CHANGED_JSON" '
                $all | map(select(. as $x | $ch | index($x)))
              '
            )"
            if [ "$(echo "$SCRIPTS_JSON" | jq 'length')" -eq 0 ]; then
              echo "Aucun script modifié → pas de payload à construire."
              exit 0
            fi
          else
            echo "Aucun script modifié → pas de payload à construire."
            exit 0
          fi
          # --- /NEW ---

          # MAP initiale : nom -> {url, sha256}
          MAP="$(
            jq -n --argjson assets "$ASSETS_JSON" '
              ($assets | map(select(.name|test("\\.sha256$")|not))) as $bins
              | ($assets | map(select(.name|test("\\.sha256$")))) as $hashes
              | reduce $bins[] as $b ({}; .[$b.name] = {url: $b.url})
              | reduce $hashes[] as $h (.;
                  .[ ($h.name|sub("\\.sha256$";"")) ] += {sha256: $h.url}
                )
            '
          )"

          TMPDIR="$(mktemp -d)"
          cleanup(){ rm -rf "$TMPDIR"; }
          trap cleanup EXIT

          for s in $(echo "$SCRIPTS_JSON" | jq -r '.[]'); do
            url="$(echo "$MAP" | jq -r --arg s "$s" '.[$s].url')"
            ver="unknown"; desc=""; usage_block=""

            if [ -n "$url" ] && curl -sSL "$url" -o "$TMPDIR/$s"; then
              # On conserve TON mode d’exécution existant (Docker) ici
              chmod -v +x "$TMPDIR/$s" || true

              docker run --rm --network none -v "$TMPDIR":/work -w /work --memory=256m --cpus=0.5 \
                ubuntu:22.04 bash -lc "\
                  set -e; \
                  apt-get update -qq >/dev/null 2>&1 || true; \
                  apt-get install -y -qq bash coreutils >/dev/null 2>&1 || true; \
                  ( timeout 6s bash /work/$s --version 2>&1 || timeout 6s bash /work/$s -V 2>&1 || true ) > /work/${s}.version.txt 2>&1 || true; \
                  ( timeout 8s bash /work/$s -h 2弊1 || timeout 8s bash /work/$s --help 2>&1 || true ) > /work/${s}.help.txt 2>&1 || true" || true

              # VERSION : privilégier la sortie dynamique, fallback header
              if [ -s "$TMPDIR/${s}.version.txt" ]; then
                ver="$(sed -E 's/\r$//g' "$TMPDIR/${s}.version.txt" | head -n 1 | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')"
                ver="$(printf "%s" "$ver" | head -c 128)"
                if [ -z "$ver" ]; then
                  ver="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$TMPDIR/$s" 2>/dev/null || true)"
                  ver="${ver:-unknown}"
                  ver="${s} v${ver}"
                fi
              else
                ver="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$TMPDIR/$s" 2>/dev/null || true)"
                ver="${ver:-unknown}"
                ver="${s} v${ver}"
              fi

              # DESCRIPTION depuis header
              desc="$(awk -F= '/^# *DESCRIPTION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$TMPDIR/$s" 2>/dev/null || true)"
              desc="${desc:-}"
              desc="$(printf "%s" "$desc" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | head -c 200)"

              # USAGE depuis sortie dynamique + normalisation 'v' sur la 1re ligne
              if [ -s "$TMPDIR/${s}.help.txt" ]; then
                help_txt="$(sed -E 's/\r$//g' "$TMPDIR/${s}.help.txt")"

                # Pat pour matcher le nom exact du script au début de la ligne (échappé pour sed)
                pat="$(printf '%s' "$s" | sed -e 's/[][(){}.^$*+?|\\/]/\\&/g')"

                first="$(printf '%s\n' "$help_txt" | head -n 1)"
                rest="$(printf '%s\n' "$help_txt" | tail -n +2 || true)"
                norm_first="$(printf '%s\n' "$first" | sed -E "s/^(${pat})([[:space:]]+)v?([0-9][0-9A-Za-z._+-]*)([[:space:]].*)?$/\\1 v\\3\\4/")"
                help_txt="${norm_first}"
                if [ -n "$rest" ]; then
                  help_txt="${help_txt}"$'\n'"${rest}"
                fi

                usage_block="$(printf "%s" "$help_txt" | sed -e 's/^[[:space:]]*//; s/[[:space:]]*$//' | head -n 200)"
                usage_block="$(printf "%s" "$usage_block" | head -c 2000)"
              else
                usage_block=""
              fi
            fi

            echo "USAGE bytes for $s: $(printf "%s" "$usage_block" | wc -c)"

            MAP="$(echo "$MAP" | jq --arg s "$s" --arg v "$ver" --arg d "$desc" --arg u "$usage_block" \
              '.[$s].version = $v | .[$s].description = $d | .[$s].usage = $u')"
          done

          printf '{"source_repo":"%s","release_tag":"%s","scripts":%s,"assets":%s}\n' \
            "$REPO" "$TAG" "$SCRIPTS_JSON" "$MAP" > payload.json

          echo "Payload built (snippet):"
          jq -c . payload.json | sed -n '1,3p' || cat payload.json

      - name: Dispatch to hugo site (no clone)
        env:
          TARGET_HUGO_REPO: ${{ vars.TARGET_HUGO_REPO }}
          HUGO_DEMO_TOKEN: ${{ secrets.HUGO_DEMO_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          # NEW: si aucun script modifié, le step précédent a exit 0 sans payload
          [ -f payload.json ] || { echo "Pas de payload (aucun script modifié) → skip dispatch."; exit 0; }

          OWNER="$(echo "$TARGET_HUGO_REPO" | cut -d/ -f1)"
          NAME="$(echo "$TARGET_HUGO_REPO" | cut -d/ -f2)"
          BODY=$(printf '{"event_type":"mes-scripts-release","client_payload":%s}' "$(cat payload.json)")

          HTTP_CODE="$(curl -sS -o /tmp/resp.json -w '%{http_code}' -X POST \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${HUGO_DEMO_TOKEN}" \
            "https://api.github.com/repos/${OWNER}/${NAME}/dispatches" \
            -d "$BODY")"

          echo "Réponse HTTP: $HTTP_CODE"
          cat /tmp/resp.json || true

          case "$HTTP_CODE" in
            204) echo "repository_dispatch envoyé avec succès." ;;
            *) echo "::error ::Échec repository_dispatch (HTTP $HTTP_CODE)"; exit 1 ;;
          esac
