#!/usr/bin/env bash
# mon-recoweb (mini) — annonces vertes, whatweb d'abord, filtres ON, per-extension, résultats en évidence
# ---------------------------------------------------------------------------------------------------
# Utilisation : mon-recoweb <IP|HOST|URL> [-x php,html,txt] [--no-filters] [-w <wordlist>] [-T <threads>] [-p <rate>] [--http|--https]
# Conserve uniquement : mon-recoweb_<target>/{whatweb.txt, summary_dirs.txt, summary_files.txt}
# Dépendances : whatweb, ffuf, curl, awk, sed
# ---------------------------------------------------------------------------------------------------
# SIG: mon-recoweb vMini-perext-whatweb-2025-09-05-g

set -euo pipefail

# VERSION=1.0.1

# --- version helpers ---
# Usage: mettre ce bloc en tête du script. Appel: --version déclenche _print_version_and_exit
_self_path="${BASH_SOURCE[0]:-$0}"
# si possible résoudre les symlinks pour afficher le nom réel du fichier
if command -v readlink >/dev/null 2>&1; then
  _resolved="$(readlink -f -- "$_self_path" 2>/dev/null || true)"
  [ -n "$_resolved" ] && _self_path="$_resolved"
fi
_self_base="$(basename "$_self_path")"

_version_str() {
  # récupère la première ligne '# VERSION=...' (tolère espaces autour de '=' et CRLF)
  # awk lit le fichier et renvoie la partie droite de '=' ; gsub retire CR si présent
  local v
  v="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$_self_path" 2>/dev/null || true)"
  [ -n "$v" ] || v="0.0.0"
  printf '%s %s\n' "$_self_base" "$v"
}

_print_version_and_exit() { _version_str; exit 0; }
# -----------------------


# Couleurs (désactivées si pas TTY)
if [[ -t 1 ]]; then
  C_B=$'\e[1m'; C_G=$'\e[32m'; C_Y=$'\e[33m'; C_R=$'\e[31m'; C_C=$'\e[36m'; C_RST=$'\e[0m'
  C_HI="${C_B}${C_C}"     # surlignage (cyan gras) pour les résultats
else
  C_B=; C_G=; C_Y=; C_R=; C_C=; C_RST=; C_HI=
fi

ok()   { echo -e "${C_G}[✓]${C_RST} $*"; }
warn() { echo -e "${C_Y}[!]${C_RST} $*"; }
err()  { echo -e "${C_R}[✗]${C_RST} $*" >&2; }

# Defaults
TARGET=""
WORDLIST="/usr/share/wordlists/dirb/common.txt"
EXTS="php,html,txt"
THREADS=40
RATE=""
OUTDIR=""
FORCE_HTTP=false
FORCE_HTTPS=false
USE_FILTERS=true
SUMMARY_CODES="200|204|301|302|307|401|403|405|500"

usage(){
  cat <<EOF
${C_B}Usage:${C_RST} mon-recoweb <IP|HOST|URL> [options]
  -x <exts>       Extensions (def: ${EXTS})
  -w <wordlist>   Wordlist (def: ${WORDLIST})
  -T <threads>    Threads ffuf (def: ${THREADS})
  -p <rate>       Tempo ffuf (ex: 50ms)
  -o <outdir>     Dossier de sortie (def: mon-recoweb_<target>)
  --http | --https
  --no-filters    Désactive -fs auto et -fc 404
  -V, --version   Afficher la version et quitter
  -h, --help      Afficher cette aide et quitter
EOF
}

# Parse positional TARGET + options
[[ $# -eq 0 ]] && { usage; exit 1; }
if [[ "${1:-}" != -* ]]; then TARGET="$1"; shift; fi
while [[ $# -gt 0 ]]; do
  case "$1" in
    -x) EXTS="$2"; shift 2 ;;
    -w) WORDLIST="$2"; shift 2 ;;
    -T) THREADS="$2"; shift 2 ;;
    -p) RATE="$2"; shift 2 ;;
    -o) OUTDIR="$2"; shift 2 ;;
    --http)  FORCE_HTTP=true; shift ;;
    --https) FORCE_HTTPS=true; shift ;;
    --no-filters) USE_FILTERS=false; shift ;;
    -V|--version) _print_version_and_exit ;;
    -h|--help) usage; exit 0 ;;
    *) err "Option inconnue: $1"; usage; exit 1 ;;
  esac
done
[[ -z "${TARGET}" ]] && { err "Cible manquante."; usage; exit 1; }

# Checks
command -v ffuf    >/dev/null 2>&1 || { err "ffuf manquant"; exit 1; }
command -v whatweb >/dev/null 2>&1 || { err "whatweb manquant"; exit 1; }
[[ -f "${WORDLIST}" ]] || { err "Wordlist introuvable: ${WORDLIST}"; exit 1; }

# Outdir
SAFE_TGT="$(echo "${TARGET}" | sed 's#[/:]#_#g')"
OUTDIR="${OUTDIR:-mon-recoweb_${SAFE_TGT}}"
mkdir -p "${OUTDIR}"; ok "Dossier : ${OUTDIR}"

# Détection schéma
if [[ "${TARGET}" =~ ^https?:// ]]; then
  BASE_URL="${TARGET%/}"
else
  if ${FORCE_HTTP}; then
    BASE_URL="http://${TARGET}"
  elif ${FORCE_HTTPS}; then
    BASE_URL="https://${TARGET}"
  else
    if curl -k -sI "https://${TARGET}" >/dev/null 2>&1; then BASE_URL="https://${TARGET}"; else BASE_URL="http://${TARGET}"; fi
  fi
fi
ok "Base URL : ${BASE_URL}"

# === 0) WHATWEB → annonce verte + enregistre + affiche en évidence ===
echo -e "${C_G}Lancement de WhatWeb...${C_RST}"
whatweb -a 3 "${BASE_URL}" | sed -r 's/\x1B\[[0-9;]*[A-Za-z]//g' > "${OUTDIR}/whatweb.txt" || true
echo -e "${C_HI}=== WHATWEB ===${C_RST}"
if [[ -s "${OUTDIR}/whatweb.txt" ]]; then
  while IFS= read -r line; do echo -e "${C_HI}${line}${C_RST}"; done < "${OUTDIR}/whatweb.txt"
else
  echo -e "${C_HI}(aucune détection)${C_RST}"
fi
echo

# Filtres auto -fs + -fc 404 (silencieux)
DIR_FILTER=""; FILE_FILTER=""; STATUS_FILTER=""
if ${USE_FILTERS}; then
  set +e
  RANDDIR="__dir__$(tr -dc 'a-z0-9' </dev/urandom | head -c 10)/"
  SIZE_DIR=$(curl -k -sS -o /dev/null -w '%{size_download}\n' "${BASE_URL}/${RANDDIR}"); [[ -z "${SIZE_DIR}" ]] && SIZE_DIR=0
  RANDFILE="__file__$(tr -dc 'a-z0-9' </dev/urandom | head -c 10).php"
  SIZE_FILE=$(curl -k -sS -o /dev/null -w '%{size_download}\n' "${BASE_URL}/${RANDFILE}"); [[ -z "${SIZE_FILE}" ]] && SIZE_FILE=0
  set -e
  [[ "${SIZE_DIR}"  != "0" ]] && DIR_FILTER="-fs ${SIZE_DIR}"
  [[ "${SIZE_FILE}" != "0" ]] && FILE_FILTER="-fs ${SIZE_FILE}"
  STATUS_FILTER="-fc 404"
fi

# Résumé dynamique (ffuf v1/v2)
summarize_csv () {
  local csv="$1" summary="$2" codes_re="$3"
  if [[ ! -s "${csv}" ]]; then : > "${summary}"; return; fi
  awk -v CODES_RE="^(""$codes_re"")$" -F',' '
    BEGIN { OFS="  " }
    NR==1 {
      for (i=1; i<=NF; i++) {
        gsub(/"/,"",$i); h=tolower($i)
        if (h=="url")                              col_url=i
        if (h=="status" || h=="status_code")      col_status=i
        if (h=="length" || h=="content_length")   col_len=i
      } next
    }
    {
      if (!col_url || !col_status) next
      for (i=1; i<=NF; i++) gsub(/"/,"",$i)
      st=$col_status; url=$col_url; ln=(col_len? $col_len : "-")
      if (st ~ CODES_RE) printf "%-3s  len=%-7s  %s\n", st, ln, url
    }
  ' "${csv}" | sort -u > "${summary}"
}

# Flags communs ffuf (aucune commande affichée à l'écran)
_ffuf_common_flags() {
  local arr=( -mc all -k -t "${THREADS}" -of csv )
  [[ -n "${RATE}" ]]          && arr+=( -p "${RATE}" )
  [[ -n "${STATUS_FILTER}" ]] && arr+=( ${STATUS_FILTER} )
  echo "${arr[@]}"
}

# ---- 1) Répertoires → annonce verte → temp → summary_dirs.txt → afficher résultats
CSV_DIRS="$(mktemp "${OUTDIR}/.dirs_XXXXXX.csv")"
echo -e "${C_G}Lancement de ffuf répertoires...${C_RST}"
ffuf -u "${BASE_URL}/FUZZ" -w "${WORDLIST}" $(_ffuf_common_flags) -o "${CSV_DIRS}" ${DIR_FILTER} >/dev/null 2>&1 || true
summarize_csv "${CSV_DIRS}" "${OUTDIR}/summary_dirs.txt" "${SUMMARY_CODES}"
echo -e "${C_HI}=== RÉPERTOIRES TROUVÉS ===${C_RST}"
if [[ -s "${OUTDIR}/summary_dirs.txt" ]]; then
  while IFS= read -r line; do echo -e "${C_HI}${line}${C_RST}"; done < "${OUTDIR}/summary_dirs.txt"
else
  echo -e "${C_HI}(aucun)${C_RST}"
fi
echo

# ---- 2) Fichiers par extensions → annonce verte → concat → summary_files.txt → afficher résultats
CSV_FILES_ALL="$(mktemp "${OUTDIR}/.files_all_XXXXXX.csv")"; : > "${CSV_FILES_ALL}"
first=true
IFS=',' read -r -a EXT_ARR <<< "${EXTS}"
echo -e "${C_G}Lancement de ffuf extensions...${C_RST}"
for raw in "${EXT_ARR[@]}"; do
  ext="${raw// /}"; [[ -z "${ext}" ]] && continue
  CSV_PART="$(mktemp "${OUTDIR}/.files_${ext}_XXXXXX.csv")"
  ffuf -u "${BASE_URL}/FUZZ.${ext}" -w "${WORDLIST}" $(_ffuf_common_flags) -o "${CSV_PART}" ${FILE_FILTER} >/dev/null 2>&1 || true
  if [[ -s "${CSV_PART}" ]]; then
    if ${first}; then cat "${CSV_PART}" >> "${CSV_FILES_ALL}"; first=false; else awk 'NR>1' "${CSV_PART}" >> "${CSV_FILES_ALL}"; fi
  fi
  rm -f "${CSV_PART}"
done

summarize_csv "${CSV_FILES_ALL}" "${OUTDIR}/summary_files.txt" "${SUMMARY_CODES}"
echo -e "${C_HI}=== FICHIERS TROUVÉS (ext: ${EXTS}) ===${C_RST}"
if [[ -s "${OUTDIR}/summary_files.txt" ]]; then
  while IFS= read -r line; do echo -e "${C_HI}${line}${C_RST}"; done < "${OUTDIR}/summary_files.txt"
else
  echo -e "${C_HI}(aucun)${C_RST}"
fi

# ---- Nettoyage des temporaires
rm -f "${CSV_DIRS}" "${CSV_FILES_ALL}"

echo
ok "Terminé."
echo "  -> ${OUTDIR}/whatweb.txt"
echo "  -> ${OUTDIR}/summary_dirs.txt"
echo "  -> ${OUTDIR}/summary_files.txt"
