#!/usr/bin/env bash
set -euo pipefail

# mon-subdomains (édition simplifiée)
# Modes :
#  -f | --fast   (défaut)  -> /usr/share/wordlists/htb-dns-vh-1000.txt
#  -m | --medium           -> /usr/share/wordlists/htb-dns-vh-2000.txt
#  -l | --large            -> /usr/share/wordlists/htb-dns-vh-5000.txt
#  --custom <file>         -> wordlist personnalisée
#
# Options utiles :
#  --https     -> cible en HTTPS (sinon HTTP)
#  -p <port>   -> port (défaut 80 ou 443 si --https)
#  --dns-only  -> n’exécute que le bruteforce DNS
#  --vhost-only-> n’exécute que le fuzzing VHOST
#  -h | --help -> aide
#
# Dépendances : ffuf, (dnsx OU gobuster), curl, (whatweb facultatif)

# ---------- Couleurs ----------
GREEN="\e[32m"; BLUE="\e[34m"; YELLOW="\e[33m"; RED="\e[31m"; BOLD="\e[1m"; RESET="\e[0m"
ok(){ echo -e "${GREEN}[✓]${RESET} $*"; }
info(){ echo -e "${BLUE}[*]${RESET} $*"; }
warn(){ echo -e "${YELLOW}[!]${RESET} $*"; }
err(){ echo -e "${RED}[x]${RESET} $*" >&2; }

usage(){
cat <<'EOF'
Usage:
  mon-subdomains <domaine.htb> [mode] [options]

Modes (un seul, défaut = --fast) :
  -f, --fast        Utilise /usr/share/wordlists/htb-dns-vh-1000.txt
  -m, --medium      Utilise /usr/share/wordlists/htb-dns-vh-2000.txt
  -l, --large       Utilise /usr/share/wordlists/htb-dns-vh-5000.txt
  --custom <file>   Utilise la wordlist fournie

Options :
  --https           Utiliser HTTPS (défaut HTTP)
  -p <port>         Port (défaut 80 ou 443 si --https)
  --dns-only        Bruteforce DNS uniquement
  --vhost-only      VHOST fuzzing uniquement
  -h, --help        Afficher l'aide

Exemples :
  mon-subdomains site.htb                 # FAST (1000)
  mon-subdomains site.htb --medium        # 2000
  mon-subdomains site.htb --large --https # 5000 en HTTPS
  mon-subdomains site.htb --custom ~/lists/mes-hosts.txt
EOF
}

need(){ command -v "$1" >/dev/null 2>&1; }

# ---------- Params ----------
DOMAIN="${1-}"
[[ -z "${DOMAIN}" || "${DOMAIN}" == "-h" || "${DOMAIN}" == "--help" ]] && { usage; exit 1; }
shift || true

MODE="fast"
WL_CUSTOM=""
HTTPS=0
PORT=""
DNS_ONLY=0
VHOST_ONLY=0

while (( "$#" )); do
  case "$1" in
    -f|--fast) MODE="fast"; shift;;
    -m|--medium) MODE="medium"; shift;;
    -l|--large) MODE="large"; shift;;
    --custom) WL_CUSTOM="${2-}"; MODE="custom"; shift 2;;
    --https) HTTPS=1; shift;;
    -p) PORT="${2-}"; shift 2;;
    --dns-only) DNS_ONLY=1; shift;;
    --vhost-only) VHOST_ONLY=1; shift;;
    -h|--help) usage; exit 0;;
    *) warn "Option inconnue: $1"; usage; exit 1;;
  esac
done

# ---------- Sélection de la wordlist ----------
WL_PATH=""
case "$MODE" in
  fast)   WL_PATH="/usr/share/wordlists/htb-dns-vh-1000.txt" ;;
  medium) WL_PATH="/usr/share/wordlists/htb-dns-vh-2000.txt" ;;
  large)  WL_PATH="/usr/share/wordlists/htb-dns-vh-5000.txt" ;;
  custom) WL_PATH="$WL_CUSTOM" ;;
esac

if [[ -z "$WL_PATH" ]]; then
  err "Aucune wordlist sélectionnée."
  exit 1
fi

if [[ ! -f "$WL_PATH" || ! -r "$WL_PATH" ]]; then
  err "Wordlist introuvable ou illisible : $WL_PATH"
  if [[ "$MODE" != "custom" ]]; then
    echo -e "  → Assure-toi d'avoir généré les listes via :"
    echo -e "    ${BOLD}make-htb-wordlist.sh --batch \"1000,2000,5000\" --with-medium --destdir /usr/share/wordlists --basename htb-dns-vh${RESET}"
  fi
  exit 1
fi

# ---------- Déterminer IP (via /etc/hosts prioritairement) ----------
TARGET_IP="$(getent hosts "$DOMAIN" | awk '{print $1}' | head -n1 || true)"
if [[ -z "${TARGET_IP}" ]]; then
  TARGET_IP="$(command -v dig >/dev/null 2>&1 && dig +short A "$DOMAIN" | head -n1 || true)"
fi

# ---------- Schéma/port ----------
SCHEME="http"; CURL_TLS=""; FFUF_TLS=""
if [[ -z "${PORT}" ]]; then
  if [[ $HTTPS -eq 1 ]]; then PORT=443; else PORT=80; fi
fi
if [[ $HTTPS -eq 1 ]]; then SCHEME="https"; CURL_TLS="--insecure"; FFUF_TLS="-k"; fi

# ---------- Dépendances ----------
[[ -z "${TARGET_IP}" ]] && warn "Impossible de déterminer l'IP de ${DOMAIN} (le VHOST fuzzing fonctionnera mieux avec /etc/hosts)."

need ffuf || { err "ffuf requis (sudo apt install ffuf)."; exit 1; }
HAS_DNSX=0; HAS_GOBUSTER=0
if need dnsx; then HAS_DNSX=1; fi
if need gobuster; then HAS_GOBUSTER=1; fi
if ! (( HAS_DNSX )) && ! (( HAS_GOBUSTER )); then
  err "dnsx ou gobuster requis pour le bruteforce DNS (sudo apt install dnsx gobuster)."
  exit 1
fi
need curl || { err "curl requis."; exit 1; }
WHATWEB=0; if need whatweb; then WHATWEB=1; fi

# ---------- Dossier sorties ----------
OUTDIR="mon-subdomains_${DOMAIN}"
mkdir -p "$OUTDIR"
ok "Dossier : $OUTDIR"
ok "Domaine : $DOMAIN"
[[ -n "${TARGET_IP}" ]] && ok "IP détectée : ${TARGET_IP}"
ok "Mode : ${MODE^^}  (wordlist: $WL_PATH)"
ok "Schéma/Port : ${SCHEME}/${PORT}"

DNS_TXT="$OUTDIR/dns_found.txt"
VHOST_TXT="$OUTDIR/vhost_found.txt"
WHATWEB_TXT="$OUTDIR/whatweb.txt"
SUMMARY_TXT="$OUTDIR/summary.txt"
SUMMARY_MD="$OUTDIR/summary.md"
FFUF_JSON="$OUTDIR/ffuf_vhosts.json"
FFUF_TXT="$OUTDIR/ffuf_vhosts.txt"
: > "$DNS_TXT"; : > "$VHOST_TXT"; : > "$WHATWEB_TXT"; : > "$SUMMARY_TXT"; : > "$SUMMARY_MD"
: > "$FFUF_TXT"

# ---------- Fonctions ----------
dns_bruteforce(){
  info "Bruteforce DNS avec $( [[ $HAS_DNSX -eq 1 ]] && echo dnsx || echo gobuster ) ..."
  if [[ $HAS_DNSX -eq 1 ]]; then
    dnsx -silent -a -d "$DOMAIN" -w "$WL_PATH" | tee -a "$DNS_TXT" || true
  else
    gobuster dns -d "$DOMAIN" -w "$WL_PATH" --no-color \
      | awk '/Found: /{print $2}' | tee -a "$DNS_TXT" || true
  fi
  local c; c=$(grep -c '.' "$DNS_TXT" || true)
  [[ "$c" -gt 0 ]] && ok "DNS: $c sous-domaines résolus." || warn "DNS: rien trouvé."
}

vhost_fuzz(){
  if [[ -z "${TARGET_IP}" ]]; then warn "Pas d'IP → VHOST fuzzing sauté."; return; fi
  info "VHOST fuzzing via ffuf (Host: FUZZ.${DOMAIN})..."
  # Calibrage taille de base
  local INVALID_HOST="x$(tr -dc 'a-z0-9' </dev/urandom | head -c8).${DOMAIN}"
  local BASE_SIZE
  BASE_SIZE=$(curl -sS $CURL_TLS --max-time 5 -H "Host: ${INVALID_HOST}" "${SCHEME}://${TARGET_IP}:${PORT}/" -o /dev/null -w "%{size_download}" || echo "0")
  info "Réponse base (Host invalide) : ${BASE_SIZE} octets"

  ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}/" $FFUF_TLS \
       -H "Host: FUZZ.${DOMAIN}" \
       -w "$WL_PATH" -mc all -r -s \
       -fs "$BASE_SIZE" \
       -o "$FFUF_JSON" -of json 2>/dev/null | tee -a "$FFUF_TXT" >/dev/null || true

  if command -v jq >/dev/null 2>&1; then
    jq -r '.results[].input.FUZZ' "$FFUF_JSON" 2>/dev/null \
      | sed "s#^#&.${DOMAIN}#" | sort -u | tee -a "$VHOST_TXT" >/dev/null || true
  else
    grep -oP '(?<=FUZZ: )[^\s]+' "$FFUF_TXT" 2>/dev/null \
      | sed "s#^#&.${DOMAIN}#" | sort -u | tee -a "$VHOST_TXT" >/dev/null || true
  fi

  local c; c=$(grep -c '.' "$VHOST_TXT" || true)
  [[ "$c" -gt 0 ]] && ok "VHOST: $c hôtes virtuels probables." || warn "VHOST: rien détecté."
}

do_whatweb(){
  [[ $WHATWEB -eq 0 ]] && return
  local targets=()
  [[ -s "$DNS_TXT" ]] && mapfile -t arr <"$DNS_TXT" && targets+=("${arr[@]}")
  [[ -s "$VHOST_TXT" ]] && mapfile -t arr2 <"$VHOST_TXT" && targets+=("${arr2[@]}")
  [[ ${#targets[@]} -eq 0 ]] && return
  info "WhatWeb sur les trouvailles..."
  for h in "${targets[@]}"; do
    whatweb -a 1 "${SCHEME}://${h}:${PORT}/" 2>/dev/null | tee -a "$WHATWEB_TXT" || true
  done
}

# ---------- Lancements ----------
if [[ $VHOST_ONLY -eq 0 ]]; then dns_bruteforce; fi
if [[ $DNS_ONLY  -eq 0 ]]; then vhost_fuzz; fi
do_whatweb

# ---------- Résumés ----------
DNS_COUNT=$(grep -c '.' "$DNS_TXT" || true)
VHOST_COUNT=$(grep -c '.' "$VHOST_TXT" || true)

{
  echo "=== mon-subdomains (${DOMAIN}) ==="
  echo "Mode        : ${MODE}"
  echo "Wordlist    : ${WL_PATH}"
  [[ -n "${TARGET_IP}" ]] && echo "IP cible   :
