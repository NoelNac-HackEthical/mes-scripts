#!/bin/bash
# NAME=mon-subdomains
# VERSION=1.0.0
# DESCRIPTION=Découverte de sous-domaines par vhost-fuzzing (ffuf) avec baseline anti-wildcard, modes fast/medium/large et options d'ajout dans /etc/hosts.
# PRESENTATION_START
# **mon-subdomains — Découverte de vhosts pour CTF / pentest**
#
# Ce script automatise la recherche de sous-domaines en se basant sur du vhost-fuzzing :
# il teste des noms Host.FQDN en interrogeant l'IP cible via ffuf et extrait les hôtes
# valides (ex. api.mon-site.htb, admin.mon-site.htb). La recherche se fait soit à partir
# d'une "master" orientée HTB soit via une wordlist custom.
#
<<<<<<< HEAD
# Principe de fonctionnement et sécurité :
# - sampling master : le script propose trois modes (fast/medium/large) qui utilisent
#   respectivement les 1000 / 2000 / 5000 premières lignes de la master (head) — rapide
#   vs exhaustif selon le besoin ;
# - anti-wildcard / baseline : il établit une baseline (code HTTP, taille, nombre de mots)
#   via un Host aléatoire pour filtrer les faux positifs (wildcards) en ajoutant -fs / -fw ;
# - sauvegarde / dry-run : l'option --save-hosts tente d'ajouter les hôtes trouvés dans
#   /etc/hosts (création d'un backup) ; --dry-run-hosts affiche ce qui serait ajouté
#   sans écrire (utile et conseillé avant toute modification système).
#
# Options pratiques et recommandations :
# - par défaut la master est : /usr/share/wordlists/htb-dns-vh-5000.txt (modifiable via --master) ;
# - mode FAST/MEDIUM/LARGE : choisir FAST en reconnaissance rapide, LARGE uniquement en lab ;
# - --strict / --codes : pour restreindre les codes HTTP retenus (ex. 200,401,403) et diminuer le bruit ;
# - --https / auto-detection : le script détecte automatiquement http/https mais on peut forcer ;
# - pour que le fuzzing vhost fonctionne, il faut que l'IP cible soit résolue — ajoute l'entrée
#   dans /etc/hosts si nécessaire (ou utiliser --save-hosts après vérification).
#
# Règles d'or :
# - commencer en fast, valider manuellement les hôtes trouvés, puis relancer medium/large en lab ;
# - ne pas activer --save-hosts sans vérification (préférer --dry-run-hosts pour contrôler) ;
# - adapter threads/timeout selon l'environnement pour éviter les blocages ou détections.
#
# Exemples :
#   mon-subdomains mon-site.htb --fast
#   mon-subdomains mon-site.htb --medium --strict --save-hosts
#   mon-subdomains mon-site.htb --custom /chemin/ma-liste.txt --https --dry-run-hosts
#
# Présentation concise : outil de vhost-fuzzing robuste, conçu pour produire une liste
# de sous-domaines exploitables et facilement vérifiables pour inclusion dans un writeup.
=======
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
# PRESENTATION_END

set -euo pipefail
LC_ALL=C

# --- version helpers ---
_self_path="${BASH_SOURCE[0]:-$0}"
if command -v readlink >/dev/null 2>&1; then
  _resolved="$(readlink -f -- "$_self_path" 2>/dev/null || true)"
  [ -n "$_resolved" ] && _self_path="$_resolved"
fi
_self_base="$(basename "$_self_path")"

_version_str() {
  local v
  v="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$_self_path" 2>/dev/null || true)"
  [ -n "$v" ] || v="0.0.0"
  printf '%s %s\n' "$_self_base" "$v"
}

_print_version_and_exit() { _version_str; exit 0; }

# --- UI helpers ---
GREEN="\e[32m"; BLUE="\e[34m"; YELLOW="\e[33m"; RESET="\e[0m"
ok(){ echo -e "${GREEN}[✓]${RESET} $*"; }
info(){ echo -e "${BLUE}[*]${RESET} $*"; }
warn(){ echo -e "${YELLOW}[!]${RESET} $*"; }

usage(){
  cat <<'USAGE'
Usage:
  mon-subdomains <domaine.htb> [mode] [options]

Modes :
  -f, --fast      1000 premières lignes de la master
  -m, --medium    2000 premières lignes
  -l, --large     5000 (entière)
  --custom FILE   Wordlist personnalisée (ignore la master)
<<<<<<< HEAD

Options :
  --master FILE     Chemin de la master 5000 (défaut: /usr/share/wordlists/htb-dns-vh-5000.txt)
  -t N              Threads ffuf (défaut: 50)
  --timeout S       Timeout curl (défaut: 8)
  --https           Forcer HTTPS (sinon auto)
  --strict          Codes restreints utiles (équiv. à --codes 200,401,403)
  --codes LIST      Liste pour ffuf -mc (ex: "200,401,403"; prend le dessus sur --strict)
  --save-hosts      Ajoute les vhosts trouvés dans /etc/hosts (backup, sans doublon)
  --dry-run-hosts   Simule l’ajout dans /etc/hosts (n’écrit rien)
  --debug           Affiche la commande ffuf et garde la sortie brute
  -V, --version     Afficher la version et quitter
  -h, --help        Aide
USAGE
}

# ---------- Version / aide rapides ----------
if [[ "${1-}" == "-V" || "${1-}" == "--version" ]]; then
  _print_version_and_exit
fi
=======
USAGE
}

# ---------- Fichier global ----------
MES_SCANS_DIR="mes_scans"
mkdir -p "$MES_SCANS_DIR"
SCAN_FILE="${MES_SCANS_DIR}/scan_vhosts.txt"
ok "Fichier de résultats : ${SCAN_FILE}"

# ----------- Parse ----------
if [[ "${1-}" == "-V" || "${1-}" == "--version" ]]; then _print_version_and_exit; fi
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28

if [[ "${1-}" == "-h" || "${1-}" == "--help" || -z "${1-}" ]]; then
  usage
  exit 0
fi

# ---------- Arguments de base ----------
DOMAIN="${1-}"
<<<<<<< HEAD
=======
if [[ -z "${DOMAIN}" ]]; then usage; exit 0; fi
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
shift || true

MODE="fast"; WL=""; THREADS=50; TIMEOUT=8
FORCE_HTTPS=0; DEBUG=0; SAVE_HOSTS=0; DRY_RUN_HOSTS=0
MASTER="/usr/share/wordlists/htb-dns-vh-5000.txt"
STRICT=0
MATCH_CODES="all"

while (( "$#" )); do
  case "$1" in
    -f|--fast) MODE="fast"; shift;;
    -m|--medium) MODE="medium"; shift;;
<<<<<<< HEAD
    -l|--large)  MODE="large"; shift;;
    --custom)    WL="${2-}"; MODE="custom"; shift 2;;
    --master)    MASTER="${2-}"; shift 2;;
    -t)          THREADS="${2-}"; shift 2;;
    --timeout)   TIMEOUT="${2-}"; shift 2;;
    --https)     FORCE_HTTPS=1; shift;;
    --strict)    STRICT=1; shift;;
    --codes)     MATCH_CODES="${2-}"; shift 2;;
    --save-hosts)    SAVE_HOSTS=1; shift;;
=======
    -l|--large) MODE="large"; shift;;
    --custom) WL="${2-}"; MODE="custom"; shift 2;;
    --master) MASTER="${2-}"; shift 2;;
    -t) THREADS="${2-}"; shift 2;;
    --timeout) TIMEOUT="${2-}"; shift 2;;
    --https) FORCE_HTTPS=1; shift;;
    --strict) STRICT=1; shift;;
    --codes) MATCH_CODES="${2-}"; shift 2;;
    --save-hosts) SAVE_HOSTS=1; shift;;
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
    --dry-run-hosts) DRY_RUN_HOSTS=1; shift;;
    --debug) DEBUG=1; shift;;
    *) warn "Option inconnue: $1"; usage; exit 1;;
  esac
done

<<<<<<< HEAD
if [[ $STRICT -eq 1 && "$MATCH_CODES" == "all" ]]; then
  MATCH_CODES="200,401,403"
fi
=======
ok "Domaine : ${DOMAIN}"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28

command -v ffuf >/dev/null || { warn "ffuf manquant"; exit 1; }
command -v curl >/dev/null || { warn "curl manquant"; exit 1; }

<<<<<<< HEAD
ok "Domaine : ${DOMAIN}"

# ---------- Fichier global mes_scans/scan_vhosts.txt ----------
MES_SCANS_DIR="mes_scans"
mkdir -p "$MES_SCANS_DIR"
SCAN_FILE="${MES_SCANS_DIR}/scan_vhosts.txt"
ok "Fichier de résultats : ${SCAN_FILE}"

# ---------- Wordlist effective (avec génération interactive) ----------
=======
# ---------- Gestion wordlist (avec génération interactive) ----------
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
WL_EFFECTIVE=""
if [[ "$MODE" == "custom" ]]; then
  [[ -f "$WL" ]] || { warn "Wordlist custom introuvable : $WL"; exit 1; }
  WL_EFFECTIVE="$WL"
<<<<<<< HEAD
  ok "Mode : CUSTOM (wordlist: $WL_EFFECTIVE)"
else
  if [[ ! -f "$MASTER" ]]; then
    if [[ "$MASTER" == "/usr/share/wordlists/htb-dns-vh-5000.txt" ]]; then
      warn "Wordlist HTB (5000 vhosts) introuvable : $MASTER"
      echo
      echo "Cette wordlist est la 'master' utilisée par défaut pour mon-subdomains."
      echo "Elle contient ~5000 noms de sous-domaines/vhosts typiques des machines HTB"
      echo "(admin, api, dev, staging, etc.) et sert de base aux modes --fast/--medium/--large."
=======
  ok "Mode : CUSTOM (wordlist $WL_EFFECTIVE)"
else
  if [[ ! -f "$MASTER" ]]; then
    if [[ "$MASTER" == "/usr/share/wordlists/htb-dns-vh-5000.txt" ]]; then
      warn "Wordlist HTB introuvable : $MASTER"
      echo "Cette wordlist contient ~5000 noms de vhosts typiques HTB (admin, api, dev...)."
      echo "Elle est utilisée par --fast / --medium / --large."
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
      echo

      if command -v make-htb-wordlist >/dev/null 2>&1; then
        read -r -p "Générer la wordlist maintenant avec 'make-htb-wordlist' ? [o/N] " rep
        case "$rep" in
          [oOyY])
            info "Lancement de make-htb-wordlist..."
            if ! make-htb-wordlist; then
<<<<<<< HEAD
              warn "Échec de make-htb-wordlist. Corrige le problème puis relance mon-subdomains."
              exit 1
            fi
            if [[ ! -f "$MASTER" ]]; then
              warn "make-htb-wordlist exécuté, mais $MASTER est toujours absent."
              echo "Vérifie la configuration de make-htb-wordlist (chemin de sortie, etc.)."
=======
              warn "Échec de make-htb-wordlist"
              exit 1
            fi

            if [[ ! -f "$MASTER" ]]; then
              warn "make-htb-wordlist exécuté, mais le fichier $MASTER est introuvable."
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
              exit 1
            fi
            ;;
          *)
<<<<<<< HEAD
            warn "Wordlist requise. Exécute 'make-htb-wordlist' manuellement puis relance mon-subdomains."
=======
            warn "Wordlist requise. Exécute : make-htb-wordlist"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
            exit 1
            ;;
        esac
      else
<<<<<<< HEAD
        warn "La commande 'make-htb-wordlist' n'est pas disponible dans le PATH."
        echo "Installe ou rends disponible ton script générateur de wordlist HTB (make-htb-wordlist),"
        echo "puis crée :"
        echo "  $MASTER"
        echo "Ensuite, relance mon-subdomains."
=======
        warn "make-htb-wordlist introuvable dans le PATH."
        echo "Génère la wordlist manuellement, puis relance."
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
        exit 1
      fi
    else
      warn "Wordlist master introuvable : $MASTER"
      exit 1
    fi
  fi

  case "$MODE" in
    fast) N=1000;;
    medium) N=2000;;
    large) N=5000;;
  esac
<<<<<<< HEAD
  WL_EFFECTIVE="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_wl.XXXXXX")"
  head -n "$N" "$MASTER" > "$WL_EFFECTIVE"
  ok "Mode : $(echo "$MODE" | tr a-z A-Z)  (wordlist: $WL_EFFECTIVE)"
  info "Master : $MASTER"
=======

  WL_EFFECTIVE="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_wl.XXXXXX")"
  head -n "$N" "$MASTER" > "$WL_EFFECTIVE"
  ok "Mode $(echo "$MODE" | tr a-z A-Z) — wordlist effective : $WL_EFFECTIVE"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
fi

# ---------- IP ----------
TARGET_IP="$(getent hosts "$DOMAIN" | awk '{print $1}' | head -n1 || true)"
[[ -z "$TARGET_IP" ]] && TARGET_IP="$(dig +short A "$DOMAIN" | head -n1 || true)"
[[ -n "$TARGET_IP" ]] && ok "IP détectée : $TARGET_IP" || warn "Aucune IP détectée"

# ---------- HTTP/HTTPS ----------
SCHEME="http"; PORT=80; CURL_TLS=""
probe(){ curl -sk --max-time "$TIMEOUT" -o /dev/null -w "%{http_code}" "$1" || true; }

if [[ $FORCE_HTTPS -eq 1 ]]; then
  SCHEME="https"; PORT=443; CURL_TLS="--insecure"
else
<<<<<<< HEAD
  # auto: si HTTP ne répond pas mais HTTPS oui, on bascule
  if [[ -n "${TARGET_IP-}" ]]; then
    if [[ "$(probe http://${TARGET_IP}:80/)" == "000" && "$(probe https://${TARGET_IP}:443/)" != "000" ]]; then
      SCHEME="https"; PORT=443; CURL_TLS="--insecure"; FFUF_TLS="-k"
    fi
=======
  if [[ "$(probe http://${DOMAIN}:80/)" == "000" && "$(probe https://${DOMAIN}:443/)" != "000" ]]; then
    SCHEME="https"; PORT=443; CURL_TLS="--insecure"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
  fi
fi
ok "Schéma : ${SCHEME}  Port : ${PORT}"

# ---------- Fichiers temporaires ----------
<<<<<<< HEAD
FFUF_RAW="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_ffuf_raw.XXXXXX")"
VHOST_TXT="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_vhosts.XXXXXX")"
: > "$VHOST_TXT"

# ---------- Baseline + test de port ----------
BASE_CODE=""; BASE_SIZE=""; BASE_WORDS=""
CAN_FUZZ=1

if [[ -z "${TARGET_IP-}" ]]; then
  warn "IP inconnue → pas de vhost fuzzing (ajoute ${DOMAIN} dans /etc/hosts si nécessaire)."
  CAN_FUZZ=0
else
  # test TCP brut pour éviter 1000 erreurs ffuf sur port fermé
  if ! timeout 3 bash -c "echo >/dev/tcp/${TARGET_IP}/${PORT}" 2>/dev/null; then
    warn "Le port ${PORT} (${SCHEME}) est fermé ou filtré → pas de vhost fuzzing."
    CAN_FUZZ=0
  fi
fi

if [[ $CAN_FUZZ -eq 1 ]]; then
  BASE_HOST="$(tr -dc 'a-z0-9' </dev/urandom | head -c 10 || echo rnd)"
  BASE_URL="${SCHEME}://${TARGET_IP}:${PORT}/"
  BASE_RESP="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" --max-time "$TIMEOUT" \
                 -o /dev/null -w "%{http_code} %{size_download}" "$BASE_URL" 2>/dev/null || true)"
  BASE_CODE="${BASE_RESP%% *}"; BASE_CODE="${BASE_CODE:-000}"
  BASE_SIZE="${BASE_RESP##* }"; BASE_SIZE="${BASE_SIZE:-0}"
  BASE_WORDS="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" --max-time "$TIMEOUT" \
                 "$BASE_URL" 2>/dev/null | wc -w | tr -d ' ' || echo 0)"
  BASE_WORDS="${BASE_WORDS:-0}"
  info "Baseline: code=${BASE_CODE} size=${BASE_SIZE} words=${BASE_WORDS} (Host=${BASE_HOST}.${DOMAIN})"
fi
=======
FFUF_RAW="$(mktemp)"
VHOST_TXT="$(mktemp)"
: > "$VHOST_TXT"

# ---------- Baseline ----------
BASE_HOST="$(tr -dc 'a-z0-9' </dev/urandom | head -c 10)"
BASE_URL="${SCHEME}://${TARGET_IP}:${PORT}/"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28

BASE_RESP="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" --max-time "$TIMEOUT" \
  -o /dev/null -w "%{http_code} %{size_download}" "$BASE_URL" || true)"

BASE_CODE="${BASE_RESP%% *}"
BASE_SIZE="${BASE_RESP##* }"
BASE_WORDS="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" "$BASE_URL" | wc -w | tr -d ' ')"

info "Baseline : code=$BASE_CODE size=$BASE_SIZE words=$BASE_WORDS"

# ---------- Parseur ffuf ----------
extract_tokens_file() {
  awk -v d="$DOMAIN" '
    { gsub(/\033\[[0-9;]*[A-Za-z]/,"",$0) }
    /Status:/ {
      if (match($0,/([a-z0-9-]{1,63})[[:space:]]*$/,m))
        print m[1]"."d
    }
  ' "$1" | sort -u
}

<<<<<<< HEAD
# ---------- VHOST fuzzing ----------
VHOST_COUNT=0

if [[ $CAN_FUZZ -eq 1 ]]; then
  info "VHOST fuzzing via ffuf ..."

  FFUF_FILTER=()
  if [[ "$BASE_CODE" != "000" ]]; then
    [[ "$BASE_SIZE"  != "0" && -n "$BASE_SIZE" ]]  && FFUF_FILTER+=(-fs "$BASE_SIZE")
    [[ "$BASE_WORDS" != "0" && -n "$BASE_WORDS" ]] && FFUF_FILTER+=(-fw "$BASE_WORDS")
  else
    info "Baseline invalide (code=000) → pas de filtre -fs/-fw appliqué à ffuf."
  fi

  CMD=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}/" $FFUF_TLS \
            -H "Host: FUZZ.${DOMAIN}" \
            -w "$WL_EFFECTIVE" -t "$THREADS" \
            -mc "${MATCH_CODES}" "${FFUF_FILTER[@]}")

  [[ $DEBUG -eq 1 ]] && echo "[*] CMD: ${CMD[*]}"
=======
# ---------- Fuzz ----------
if [[ -n "${TARGET_IP-}" ]]; then
  info "Scan VHOST…"

  FFUF_FILTER=()
  [[ "$BASE_SIZE" != "0" ]] && FFUF_FILTER+=(-fs "$BASE_SIZE")
  [[ "$BASE_WORDS" != "0" ]] && FFUF_FILTER+=(-fw "$BASE_WORDS")

  CMD=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}/" \
       -H "Host: FUZZ.${DOMAIN}" -w "$WL_EFFECTIVE" \
       -t "$THREADS" -mc "$MATCH_CODES" "${FFUF_FILTER[@]}")
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28

  [[ $DEBUG -eq 1 ]] && echo "CMD: ${CMD[*]}"
  "${CMD[@]}" > "$FFUF_RAW" 2>&1 || true
<<<<<<< HEAD
  extract_tokens_file "$FFUF_RAW" > "$VHOST_TXT" || true

  VHOST_COUNT="$(grep -c '.' "$VHOST_TXT" || true)"
  if [[ "$VHOST_COUNT" -gt 0 ]]; then
    ok "VHOST: ${VHOST_COUNT} hôtes."
    echo -e "${GREEN}[✓]${RESET} VHOST trouvés :"
    sed 's/^/   • /' "$VHOST_TXT"
  else
    warn "VHOST: rien trouvé."
    if grep -q "Errors: " "$FFUF_RAW" 2>/dev/null; then
      info "ffuf a rencontré des erreurs (voir fichier brut pour le détail)."
    fi
  fi
fi

# ---------- /etc/hosts ----------
if [[ $SAVE_HOSTS -eq 1 || $DRY_RUN_HOSTS -eq 1 ]]; then
  if [[ "$VHOST_COUNT" -eq 0 ]]; then
    warn "Pas de vhost trouvé → rien à faire pour /etc/hosts."
  elif [[ -z "${TARGET_IP-}" ]]; then
    warn "IP inconnue → impossible d’écrire dans /etc/hosts."
  else
    if [[ $DRY_RUN_HOSTS -eq 1 ]]; then
      info "[DRY-RUN] Lignes qui seraient ajoutées à /etc/hosts :"
      while IFS= read -r host; do
        echo "${TARGET_IP} ${host}"
      done < "$VHOST_TXT"
    else
      TS="$(date +%Y%m%d-%H%M%S)"
      BACKUP="/etc/hosts.bak.${TS}"
      info "Sauvegarde: ${BACKUP}"
      if sudo cp /etc/hosts "$BACKUP"; then
        ADDED=0
        while IFS= read -r host; do
          if ! grep -qw "$host" /etc/hosts; then
            echo "${TARGET_IP} ${host}" | sudo tee -a /etc/hosts >/dev/null
            ((ADDED++))
          fi
        done < "$VHOST_TXT"
        [[ $ADDED -gt 0 ]] && ok "--save-hosts : ${ADDED} entrées ajoutées" || info "Aucun ajout (déjà présent)."
      else
        warn "Backup /etc/hosts échoué → abandon de --save-hosts."
=======

  extract_tokens_file "$FFUF_RAW" > "$VHOST_TXT"
else
  warn "Pas d’IP → pas de fuzz VHOST."
fi

VHOST_COUNT="$(grep -c . "$VHOST_TXT" || true)"
ok "$VHOST_COUNT vhosts trouvés"

# ---------- /etc/hosts ----------
if [[ $SAVE_HOSTS -eq 1 || $DRY_RUN_HOSTS -eq 1 ]]; then
  if [[ $VHOST_COUNT -eq 0 ]]; then warn "Aucun vhost → rien à ajouter."; fi

  if [[ -z "${TARGET_IP-}" ]]; then warn "IP inconnue → pas d'ajout hosts"; fi

  if [[ $DRY_RUN_HOSTS -eq 1 ]]; then
    info "[DRY RUN] Entrées /etc/hosts :"
    while read -r h; do echo "$TARGET_IP $h"; done < "$VHOST_TXT"
  else
    TS="$(date +%Y%m%d-%H%M%S)"
    sudo cp /etc/hosts "/etc/hosts.bak.${TS}"
    while read -r h; do
      if ! grep -qw "$h" /etc/hosts; then
        echo "$TARGET_IP $h" | sudo tee -a /etc/hosts >/dev/null
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
      fi
    done < "$VHOST_TXT"
  fi
fi

<<<<<<< HEAD
# ---------- Mise à jour du fichier global mes_scans/scan_vhosts.txt ----------
BLOCK_START="=== mon-subdomains ${DOMAIN} START ==="
BLOCK_END="=== mon-subdomains ${DOMAIN} END ==="

# Supprimer un éventuel bloc existant pour ce domaine
if [[ -f "$SCAN_FILE" ]]; then
  sed -e "/^=== mon-subdomains ${DOMAIN} START ===\$/,/^=== mon-subdomains ${DOMAIN} END ===\$/d" \
=======
# ---------- Mise à jour du fichier global ----------
BLOCK_START="=== mon-subdomains ${DOMAIN} START ==="
BLOCK_END="=== mon-subdomains ${DOMAIN} END ==="

if [[ -f "$SCAN_FILE" ]]; then
  sed "/^=== mon-subdomains ${DOMAIN} START ===\$/,/^=== mon-subdomains ${DOMAIN} END ===\$/d" \
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28
    "$SCAN_FILE" > "${SCAN_FILE}.tmp" || true
  mv "${SCAN_FILE}.tmp" "$SCAN_FILE"
fi

{
  echo "$BLOCK_START"
<<<<<<< HEAD
  echo "Script       : mon-subdomains"
  echo "Version      : $(_version_str)"
  echo "Date         : $(date '+%F %T')"
  echo "Domaine      : ${DOMAIN}"
  [[ -n "${TARGET_IP-}" ]] && echo "IP           : ${TARGET_IP}" || echo "IP           : (non détectée)"
  echo "Schéma/Port  : ${SCHEME}/${PORT}"
  echo "Mode         : ${MODE}"
  echo "Wordlist eff.: ${WL_EFFECTIVE}"
  echo "Master       : ${MASTER}"
  echo "Codes        : ${MATCH_CODES}  (strict=${STRICT})"
  if [[ -n "$BASE_CODE" ]]; then
    echo "Baseline     : code=${BASE_CODE} size=${BASE_SIZE} words=${BASE_WORDS}"
  else
    echo "Baseline     : non effectuée (port fermé ou IP inconnue)"
  fi
  echo
  echo "VHOST (${VHOST_COUNT})"
  if [[ -s "$VHOST_TXT" ]]; then
    sed 's/^/  - /' "$VHOST_TXT"
  else
    echo "  - (aucun)"
  fi
  echo
  echo "--- Debug ---"
  echo "ffuf raw     : ${FFUF_RAW}"
  echo "$BLOCK_END"
  echo
} >> "$SCAN_FILE"

ok "Bloc mis à jour dans ${SCAN_FILE} pour le domaine ${DOMAIN}"
=======
  echo "Script: mon-subdomains  Version: $(_version_str)"
  echo "Date: $(date '+%F %T')"
  echo "Domaine: $DOMAIN"
  echo "IP: ${TARGET_IP:-non détectée}"
  echo "Schéma/Port: $SCHEME/$PORT"
  echo "Mode: $MODE"
  echo "Wordlist effective: $WL_EFFECTIVE"
  echo "Master: $MASTER"
  echo "VHOST ($VHOST_COUNT):"
  sed 's/^/  - /' "$VHOST_TXT"
  echo "$BLOCK_END"
  echo
} >> "$SCAN_FILE"

ok "Bloc ajouté dans : $SCAN_FILE"
>>>>>>> 0e609c608f43fb01c256429ad4d1704c860dea28

exit 0
