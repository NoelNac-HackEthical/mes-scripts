#!/bin/bash
# NAME=mon-subdomains
# VERSION=1.0.0
# DESCRIPTION=Découverte de sous-domaines par vhost-fuzzing (ffuf) avec baseline anti-wildcard, modes fast/medium/large et options d'ajout dans /etc/hosts.
# PRESENTATION_START
# **mon-subdomains — Découverte de vhosts pour CTF / pentest**
#
# Ce script automatise la recherche de sous-domaines en se basant sur du vhost-fuzzing :
# il teste des noms Host.FQDN en interrogeant l'IP cible via ffuf et extrait les hôtes
# valides (ex. api.mon-site.htb, admin.mon-site.htb). La recherche se fait soit à partir
# d'une "master" orientée HTB soit via une wordlist custom.
#
# Principe de fonctionnement et sécurité :
# - sampling master : le script propose trois modes (fast/medium/large) qui utilisent
#   respectivement les 1000 / 2000 / 5000 premières lignes de la master (head) — rapide
#   vs exhaustif selon le besoin ;
# - anti-wildcard / baseline : il établit une baseline (code HTTP, taille, nombre de mots)
#   via un Host aléatoire pour filtrer les faux positifs (wildcards) en ajoutant -fs / -fw ;
# - sauvegarde / dry-run : l'option --save-hosts tente d'ajouter les hôtes trouvés dans
#   /etc/hosts (création d'un backup) ; --dry-run-hosts affiche ce qui serait ajouté
#   sans écrire (utile et conseillé avant toute modification système).
#
# Options pratiques et recommandations :
# - par défaut la master est : /usr/share/wordlists/htb-dns-vh-5000.txt (modifiable via --master) ;
# - mode FAST/MEDIUM/LARGE : choisir FAST en reconnaissance rapide, LARGE uniquement en lab ;
# - --strict / --codes : pour restreindre les codes HTTP retenus (ex. 200,401,403) et diminuer le bruit ;
# - --https / auto-detection : le script détecte automatiquement http/https mais on peut forcer ;
# - pour que le fuzzing vhost fonctionne, il faut que l'IP cible soit résolue — ajoute l'entrée
#   dans /etc/hosts si nécessaire (ou utiliser --save-hosts après vérification).
#
# Règles d'or :
# - commencer en fast, valider manuellement les hôtes trouvés, puis relancer medium/large en lab ;
# - ne pas activer --save-hosts sans vérification (préférer --dry-run-hosts pour contrôler) ;
# - adapter threads/timeout selon l'environnement pour éviter les blocages ou détections.
#
# Exemples :
#   ./mon-subdomains mon-site.htb --fast
#   ./mon-subdomains mon-site.htb --medium --strict --save-hosts
#   ./mon-subdomains mon-site.htb --custom /chemin/ma-liste.txt --https --dry-run-hosts
#
# Présentation concise : outil de vhost-fuzzing robuste, conçu pour produire une liste
# de sous-domaines exploitables et facilement vérifiables pour inclusion dans un writeup.
# PRESENTATION_END

set -euo pipefail
LC_ALL=C

# --- version helpers ---
# Usage: mettre ce bloc en tête du script. Appel: --version déclenche _print_version_and_exit
_self_path="${BASH_SOURCE[0]:-$0}"
# si possible résoudre les symlinks pour afficher le nom réel du fichier
if command -v readlink >/dev/null 2>&1; then
  _resolved="$(readlink -f -- "$_self_path" 2>/dev/null || true)"
  [ -n "$_resolved" ] && _self_path="$_resolved"
fi
_self_base="$(basename "$_self_path")"

_version_str() {
  # récupère la première ligne '# VERSION=...' (tolère espaces autour de '=' et CRLF)
  # awk lit le fichier et renvoie la partie droite de '=' ; gsub retire CR si présent
  local v
  v="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$_self_path" 2>/dev/null || true)"
  [ -n "$v" ] || v="0.0.0"
  printf '%s %s\n' "$_self_base" "$v"
}

_print_version_and_exit() { _version_str; exit 0; }
# -----------------------


# mon-subdomains — v0.3
# - VHOST fuzzing via ffuf
# - Master 5000 unique (FAST=1000 / MEDIUM=2000 / LARGE=5000 via head)
# - Baseline anti-wildcard: -fs (size) + -fw (words)
# - Parse robuste sortie console ffuf (lignes "collées")
# - Options: --strict (mc=200,401,403), --codes, --save-hosts, --dry-run-hosts, --https, --debug

GREEN="\e[32m"; BLUE="\e[34m"; YELLOW="\e[33m"; RESET="\e[0m"
ok(){ echo -e "${GREEN}[✓]${RESET} $*"; }
info(){ echo -e "${BLUE}[*]${RESET} $*"; }
warn(){ echo -e "${YELLOW}[!]${RESET} $*"; }

usage(){
  cat <<'USAGE'
Usage:
  mon-subdomains <domaine.htb> [mode] [options]

Modes :
  -f, --fast      1000 premières lignes de la master
  -m, --medium    2000 premières lignes
  -l, --large     5000 (entière)
  --custom FILE   Wordlist personnalisée (ignore la master)

Options :
  --master FILE     Chemin de la master 5000 (défaut: /usr/share/wordlists/htb-dns-vh-5000.txt)
  -t N              Threads ffuf (défaut: 50)
  --timeout S       Timeout curl (défaut: 8)
  --https           Forcer HTTPS (sinon auto)
  --strict          Codes restreints utiles (équiv. à --codes 200,401,403)
  --codes LIST      Liste pour ffuf -mc (ex: "200,401,403"; prend le dessus sur --strict)
  --save-hosts      Ajoute les vhosts trouvés dans /etc/hosts (backup, sans doublon)
  --dry-run-hosts   Simule l’ajout dans /etc/hosts (n’écrit rien)
  --debug           Affiche la commande ffuf et garde la sortie brute
  -V, --version     Afficher la version et quitter
  -h, --help        Aide

Exemples :
  mon-subdomains site.htb --fast
  mon-subdomains permx.htb --fast --strict
  mon-subdomains target.htb --medium --codes 200,403 --save-hosts
USAGE
}

# ---------- Parse ----------
# Pré-check : si le premier argument est -V/--version, afficher et quitter (évite de le prendre comme <domaine>)
if [[ "${1-}" == "-V" || "${1-}" == "--version" ]]; then _print_version_and_exit; fi

DOMAIN="${1-}"
if [[ -z "${DOMAIN}" || "${DOMAIN}" == "-h" || "${DOMAIN}" == "--help" ]]; then usage; exit 0; fi
shift || true

MODE="fast"; WL=""; THREADS=50; TIMEOUT=8
FORCE_HTTPS=0; DEBUG=0; SAVE_HOSTS=0; DRY_RUN_HOSTS=0
MASTER="/usr/share/wordlists/htb-dns-vh-5000.txt"
STRICT=0
MATCH_CODES="all"   # par défaut

while (( "$#" )); do
  case "$1" in
    -f|--fast)   MODE="fast"; shift;;
    -m|--medium) MODE="medium"; shift;;
    -l|--large)  MODE="large"; shift;;
    --custom)    WL="${2-}"; MODE="custom"; shift 2;;
    --master)    MASTER="${2-}"; shift 2;;
    -t)          THREADS="${2-}"; shift 2;;
    --timeout)   TIMEOUT="${2-}"; shift 2;;
    --https)     FORCE_HTTPS=1; shift;;
    --strict)    STRICT=1; shift;;
    --codes)     MATCH_CODES="${2-}"; shift 2;;
    --save-hosts) SAVE_HOSTS=1; shift;;
    --dry-run-hosts) DRY_RUN_HOSTS=1; shift;;
    --debug)     DEBUG=1; shift;;
    -V|--version) _print_version_and_exit ;;
    -h|--help)   usage; exit 0;;
    *) warn "Option inconnue: $1"; usage; exit 1;;
  esac
done

# Si --strict demandé et pas de --codes explicite, applique les codes stricts
if [[ $STRICT -eq 1 && "$MATCH_CODES" == "all" ]]; then
  MATCH_CODES="200,401,403"
fi

# ---------- Outils ----------
command -v ffuf >/dev/null || { warn "ffuf manquant"; exit 1; }
command -v curl >/dev/null || { warn "curl manquant"; exit 1; }

# ---------- Dossier & WL effective ----------
OUTDIR="mon-subdomains_${DOMAIN}"
mkdir -p "$OUTDIR"
ok "Dossier : $OUTDIR"
ok "Domaine : $DOMAIN"

if [[ "$MODE" == "custom" ]]; then
  [[ -f "$WL" ]] || { warn "Wordlist custom introuvable: $WL"; exit 1; }
  ok "Mode : CUSTOM  (wordlist: $WL)"
else
  [[ -f "$MASTER" ]] || { warn "Master introuvable: $MASTER"; exit 1; }
  case "$MODE" in
    fast)   N=1000;;
    medium) N=2000;;
    large)  N=5000;;
  esac
  WL="$OUTDIR/effective_wordlist.txt"
  head -n "$N" "$MASTER" > "$WL"
  ok "Mode : $(echo "$MODE" | tr a-z A-Z)  (wordlist: $WL)"
  info "Master : $MASTER"
fi

# ---------- Résolution IP ----------
TARGET_IP="$(getent hosts "$DOMAIN" | awk '{print $1}' | head -n1 || true)"
[[ -z "$TARGET_IP" ]] && TARGET_IP="$(dig +short A "$DOMAIN" 2>/dev/null | head -n1 || true)"
[[ -n "$TARGET_IP" ]] && ok "IP détectée : $TARGET_IP" || warn "IP non détectée"

# ---------- HTTP/HTTPS ----------
SCHEME="http"; PORT=80; CURL_TLS=""; FFUF_TLS=""
probe(){ curl -sk --max-time "$TIMEOUT" -o /dev/null -w "%{http_code}" "$1" || true; }
if [[ $FORCE_HTTPS -eq 1 ]]; then
  SCHEME="https"; PORT=443; CURL_TLS="--insecure"; FFUF_TLS="-k"
else
  if [[ "$(probe http://${DOMAIN}:80/)" == "000" && "$(probe https://${DOMAIN}:443/)" != "000" ]]; then
    SCHEME="https"; PORT=443; CURL_TLS="--insecure"; FFUF_TLS="-k"
  fi
fi
ok "Schéma/Port : ${SCHEME}/${PORT}"

# ---------- Fichiers ----------
VHOST_TXT="$OUTDIR/vhost_found.txt"
SUMMARY_TXT="$OUTDIR/summary.txt"
FFUF_RAW="$OUTDIR/ffuf_vhosts.txt"
: > "$VHOST_TXT"; : > "$SUMMARY_TXT"

# ---------- Échantillon baseline ----------
BASE_HOST="$(tr -dc 'a-z0-9' </dev/urandom | head -c 10 || echo rnd)"
BASE_URL="${SCHEME}://${TARGET_IP}:${PORT}/"
BASE_RESP="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" --max-time "$TIMEOUT" -o /dev/null -w "%{http_code} %{size_download}" "$BASE_URL" 2>/dev/null || true)"
BASE_CODE="${BASE_RESP%% *}"; BASE_CODE="${BASE_CODE:-000}"
BASE_SIZE="${BASE_RESP##* }"; BASE_SIZE="${BASE_SIZE:-0}"
BASE_WORDS="$(curl -sk ${CURL_TLS:-} -H "Host: ${BASE_HOST}.${DOMAIN}" --max-time "$TIMEOUT" "$BASE_URL" 2>/dev/null | wc -w | tr -d ' ' || echo 0)"
BASE_WORDS="${BASE_WORDS:-0}"
info "Baseline: code=${BASE_CODE} size=${BASE_SIZE} words=${BASE_WORDS} (Host=${BASE_HOST}.${DOMAIN})"

# ---------- Parseur robuste (console ffuf) ----------
extract_tokens_file() {
  local f="$1"
  awk -v d="$DOMAIN" '
    {
      line=$0
      gsub(/\r/,"",line)
      gsub(/\033\[[0-9;]*[A-Za-z]/,"",line)
      if (index(line,"[Status:")>0) {
        n = split(line, a, /\[Status:/)
        left = a[1]
        if (match(left, /([a-z0-9-]{1,63})[[:space:]]*$/, m)) {
          print m[1] "." d
        }
      }
    }
  ' "$f" | sort -u
}

# ---------- VHOST fuzzing ----------
if [[ -n "${TARGET_IP-}" ]]; then
  info "VHOST fuzzing via ffuf ..."
  FFUF_FILTER=()
  [[ "${BASE_SIZE}"  != "0" ]] && FFUF_FILTER+=(-fs "$BASE_SIZE")
  [[ "${BASE_WORDS}" != "0" ]] && FFUF_FILTER+=(-fw "$BASE_WORDS")

  CMD=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}/" $FFUF_TLS \
            -H "Host: FUZZ.${DOMAIN}" \
            -w "$WL" -t "$THREADS" \
            -mc "${MATCH_CODES}" "${FFUF_FILTER[@]}")

  [[ $DEBUG -eq 1 ]] && echo "[*] CMD: ${CMD[*]}"

  "${CMD[@]}" > "$FFUF_RAW" 2>&1 || true
  extract_tokens_file "$FFUF_RAW" > "$VHOST_TXT" || true
else
  warn "Pas d'IP → ajoute l’IP de $DOMAIN dans /etc/hosts pour que le vhost fuzzing fonctionne."
fi

VHOST_COUNT="$(grep -c '.' "$VHOST_TXT" || true)"
if [[ "$VHOST_COUNT" -gt 0 ]]; then
  ok "VHOST: ${VHOST_COUNT} hôtes."
  echo -e "${GREEN}[✓]${RESET} VHOST trouvés :"
  sed 's/^/   • /' "$VHOST_TXT"
else
  warn "VHOST: rien trouvé."
  [[ -f "$FFUF_RAW" ]] && { echo "[i] Extrait ffuf:"; sed -n '1,120p' "$FFUF_RAW"; }
fi

# ---------- /etc/hosts ----------
if [[ $SAVE_HOSTS -eq 1 || $DRY_RUN_HOSTS -eq 1 ]]; then
  if [[ "$VHOST_COUNT" -eq 0 ]]; then
    warn "Pas de vhost trouvé → rien à faire."
  elif [[ -z "${TARGET_IP-}" ]]; then
    warn "IP inconnue → impossible d’écrire dans /etc/hosts."
  else
    if [[ $DRY_RUN_HOSTS -eq 1 ]]; then
      info "[DRY-RUN] Lignes qui seraient ajoutées à /etc/hosts :"
      while IFS= read -r host; do
        echo "${TARGET_IP} ${host}"
      done < "$VHOST_TXT"
    else
      TS="$(date +%Y%m%d-%H%M%S)"
      BACKUP="/etc/hosts.bak.${TS}"
      info "Sauvegarde: ${BACKUP}"
      if sudo cp /etc/hosts "$BACKUP"; then
        ADDED=0
        while IFS= read -r host; do
          if ! grep -qw "$host" /etc/hosts; then
            echo "${TARGET_IP} ${host}" | sudo tee -a /etc/hosts >/dev/null
            ((ADDED++))
          fi
        done < "$VHOST_TXT"
        [[ $ADDED -gt 0 ]] && ok "--save-hosts : ${ADDED} entrées ajoutées" || info "Aucun ajout (déjà présent)"
      else
        warn "Backup /etc/hosts échoué → abandon de --save-hosts"
      fi
    fi
  fi
fi

# ---------- Résumé ----------
{
  echo "=== mon-subdomains (${DOMAIN}) — v0.3 ==="
  echo "Date: $(date '+%F %T')"
  [[ -n "${TARGET_IP-}" ]] && echo "IP: ${TARGET_IP}"
  echo "Schéma/Port: ${SCHEME}/${PORT}"
  echo "Wordlist effective: ${WL}"
  [[ "$MODE" != "custom" ]] && echo "Master: ${MASTER}"
  echo "Codes: ${MATCH_CODES}  (strict=${STRICT})"
  echo "Baseline: size=${BASE_SIZE} words=${BASE_WORDS} (code=${BASE_CODE})"
  echo
  echo "VHOST (${VHOST_COUNT})"
  if [[ -s "$VHOST_TXT" ]]; then sed 's/^/  - /' "$VHOST_TXT"; else echo "  - (aucun)"; fi
  echo
  echo "--- Debug files ---"
  echo "ffuf raw : $FFUF_RAW"
} > "$SUMMARY_TXT"

exit 0
