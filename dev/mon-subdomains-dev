#!/usr/bin/env bash
# NAME=mon-subdomains-dev
# VERSION=2.1.4
# DESCRIPTION=Découverte de sous-domaines par vhost-fuzzing (ffuf) avec baselines robustes, anti-wildcard contrôlé, gestion des redirects 3xx (curl -L + ffuf -r), parsing fiable via JSON (jq), modes fast/medium/large et options /etc/hosts.
# PRESENTATION_START
# **mon-subdomains — Découverte de vhosts pour CTF / pentest**
#
# Ce script automatise la recherche de sous-domaines en se basant sur du vhost-fuzzing :
# il teste des noms Host.FQDN en interrogeant l'IP cible via ffuf et extrait les hôtes
# valides (ex. api.mon-site.htb, admin.mon-site.htb).
#
# - Résolution IP du domaine + ping cohérence /etc/hosts
# - Scan Nmap interne (-Pn -sV -p-) pour détecter les ports HTTP/HTTPS
# - ffuf Host: FUZZ.domaine.htb sur chaque port web
# - Sortie agrégée dans mes_scans/scan_vhosts.txt (bloc remplacé à chaque run)
#
# PRESENTATION_END

set -euo pipefail
LC_ALL=C

# --- version helpers ---
_self_path="${BASH_SOURCE[0]:-$0}"
if command -v readlink >/dev/null 2>&1; then
  _resolved="$(readlink -f -- "$_self_path" 2>/dev/null || true)"
  [[ -n "${_resolved:-}" ]] && _self_path="$_resolved"
fi
_self_base="$(basename "$_self_path")"

_version_str() {
  local v
  v="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$_self_path" 2>/dev/null || true)"
  [[ -n "${v:-}" ]] || v="0.0.0"
  printf '%s %s\n' "$_self_base" "$v"
}
_print_version_and_exit(){ _version_str; exit 0; }

# --- UI helpers ---
GREEN="\e[32m"; BLUE="\e[34m"; YELLOW="\e[33m"; RESET="\e[0m"
ok(){ echo -e "${GREEN}[✓]${RESET} $*"; }
info(){ echo -e "${BLUE}[*]${RESET} $*"; }
warn(){ echo -e "${YELLOW}[!]${RESET} $*"; }

usage(){
  cat <<'USAGE'
Usage:
  mon-subdomains <domaine.htb> [mode] [options]

Modes :
  -f, --fast      1000 premières lignes de la master
  -m, --medium    2000 premières lignes
  -l, --large     5000 (entière)
  --custom FILE   Wordlist personnalisée (ignore la master)

Options :
  --master FILE     Chemin de la master 5000 (défaut: /usr/share/wordlists/htb-dns-vh-5000.txt)
  -t N              Threads ffuf (défaut: 50)
  --timeout S       Timeout curl (défaut: 8)
  --strict          Codes restreints utiles (équiv. à --codes 200,401,403)
  --codes LIST      Liste pour ffuf -mc (ex: "200,401,403"; prend le dessus sur --strict)
  --save-hosts      Ajoute les vhosts trouvés dans /etc/hosts (backup, sans doublon)
  --dry-run-hosts   Simule l’ajout dans /etc/hosts (n’écrit rien)
  --debug           Affiche la commande ffuf et garde la sortie brute (fichiers /tmp)
  -V, --version     Afficher la version et quitter
  -h, --help        Aide
USAGE
}

# ---------- Nmap helper (style mon-scan, sans emojis/symboles) ----------
_run_nmap_scan() {
  # args: target_ip nmap_outfile
  local ip="$1" out="$2"

  info "Nmap : détection des services web (HTTP/HTTPS)"

  if ! nmap -Pn -sV -p- --min-rate 5000 -T4 --max-retries 3 --stats-every 2s \
           -oN "$out" "$ip"; then
    warn "Échec du scan Nmap interne sur ${ip}."
  fi
}

# ---------- Baseline helpers ----------
_fetch_baseline_metrics() {
  # args: scheme ip port domain timeout follow_redirects(0/1)
  local scheme="$1" ip="$2" port="$3" domain="$4" timeout="$5" follow="${6:-0}"

  local bh code size words url
  local -a curl_tls curl_follow

  # token non vide (important avec set -u)
  bh="$(tr -dc 'a-z0-9' </dev/urandom | head -c 10 2>/dev/null || true)"
  [[ -n "$bh" ]] || bh="rnd$RANDOM"

  url="${scheme}://${ip}:${port}/"

  curl_tls=()
  [[ "$scheme" == "https" ]] && curl_tls+=(--insecure)

  curl_follow=()
  [[ "$follow" == "1" ]] && curl_follow+=(-L)

  read -r code size < <(
    curl -s "${curl_tls[@]}" "${curl_follow[@]}" \
      -H "Host: ${bh}.${domain}" --max-time "$timeout" \
      -o /dev/null -w "%{http_code} %{size_download}\n" "$url" 2>/dev/null \
    || echo "000 0"
  )

  words="$(
    curl -s "${curl_tls[@]}" "${curl_follow[@]}" \
      -H "Host: ${bh}.${domain}" --max-time "$timeout" \
      "$url" 2>/dev/null | wc -w | tr -d ' ' || echo 0
  )"

  code="${code:-000}"; size="${size:-0}"; words="${words:-0}"
  printf '%s %s %s %s\n' "$bh" "$code" "$size" "$words"
}

_abs(){ local x="$1"; ((x<0)) && x=$(( -x )); echo "$x"; }

_is_wildcard_likely() {
  # args: code1 size1 words1 code2 size2 words2 code3 size3 words3
  local c1="$1" s1="$2" w1="$3" c2="$4" s2="$5" w2="$6" c3="$7" s3="$8" w3="$9"

  # 3xx stable = souvent redirect “default vhost” → ne PAS conclure wildcard
  if [[ "$c1" =~ ^3 && "$c2" =~ ^3 && "$c3" =~ ^3 ]]; then
    return 1
  fi

  [[ "$c1" == "000" || "$c2" == "000" || "$c3" == "000" ]] && return 1
  [[ "$c1" != "$c2" || "$c1" != "$c3" ]] && return 1

  local ds12 ds13 dw12 dw13
  ds12="$(_abs $((s1 - s2)))"
  ds13="$(_abs $((s1 - s3)))"
  dw12="$(_abs $((w1 - w2)))"
  dw13="$(_abs $((w1 - w3)))"

  (( ds12 <= 10 && ds13 <= 10 && dw12 <= 2 && dw13 <= 2 ))
}

_needs_autocalibration() {
  # args: size1 words1 size2 words2 size3 words3
  local s1="$1" w1="$2" s2="$3" w2="$4" s3="$5" w3="$6"
  local ds12 ds13 dw12 dw13
  ds12="$(_abs $((s1 - s2)))"
  ds13="$(_abs $((s1 - s3)))"
  dw12="$(_abs $((w1 - w2)))"
  dw13="$(_abs $((w1 - w3)))"

  (( ds12 > 50 || ds13 > 50 || dw12 > 10 || dw13 > 10 ))
}

# JSON ffuf → vhosts (token FUZZ)
extract_ffuf_json_to_vhosts() {
  # args: json_file domain
  local jf="$1" dom="$2"
  jq -r '.results[].input.FUZZ // empty' "$jf" 2>/dev/null \
    | awk 'NF{print $0}' \
    | sed "s/$/.${dom}/" \
    | sort -u
}

# Détection des endpoints HTTP/HTTPS à partir d'un fichier Nmap -sV
# Retourne sur stdout des lignes "port:scheme" (ex: "80:http", "443:https")
detect_web_endpoints_from_nmap() {
  local nmap_file="$1"
  [[ -f "$nmap_file" ]] || return 1

  local endpoints=()
  local line port svc rest text scheme

  while IFS= read -r line; do
    if [[ "$line" =~ ^([0-9]+)/tcp[[:space:]]+open[[:space:]]+([^[:space:]]+)[[:space:]]*(.*)$ ]]; then
      port="${BASH_REMATCH[1]}"
      svc="${BASH_REMATCH[2]}"
      rest="${BASH_REMATCH[3]}"
      text="${svc} ${rest}"
      if grep -qi 'http' <<<"$text"; then
        scheme="http"
        if grep -qiE 'https|ssl/http|tls' <<<"$text"; then
          scheme="https"
        fi
        endpoints+=("${port}:${scheme}")
      fi
    fi
  done < "$nmap_file"

  ((${#endpoints[@]} == 0)) && return 1
  printf '%s\n' "${endpoints[@]}" | sort -n | uniq
  return 0
}

# ---------- Version / aide ----------
if [[ "${1-}" == "-V" || "${1-}" == "--version" ]]; then
  _print_version_and_exit
fi
if [[ "${1-}" == "-h" || "${1-}" == "--help" || -z "${1-}" ]]; then
  usage
  exit 0
fi

# ---------- Arguments ----------
DOMAIN="${1-}"
shift || true

MODE="large"; WL=""; THREADS=50; TIMEOUT=8
MASTER="/usr/share/wordlists/htb-dns-vh-5000.txt"
STRICT=1
MATCH_CODES="all"
DEBUG=0
SAVE_HOSTS=0
DRY_RUN_HOSTS=0

while (( "$#" )); do
  case "$1" in
    -f|--fast)   MODE="fast"; shift;;
    -m|--medium) MODE="medium"; shift;;
    -l|--large)  MODE="large"; shift;;
    --custom)    WL="${2-}"; MODE="custom"; shift 2;;
    --master)    MASTER="${2-}"; shift 2;;
    -t)          THREADS="${2-}"; shift 2;;
    --timeout)   TIMEOUT="${2-}"; shift 2;;
    --strict)    STRICT=1; shift;;
    --codes)     MATCH_CODES="${2-}"; shift 2;;
    --save-hosts)    SAVE_HOSTS=1; shift;;
    --dry-run-hosts) DRY_RUN_HOSTS=1; shift;;
    --debug)     DEBUG=1; shift;;
    -V|--version) _print_version_and_exit ;;
    -h|--help)   usage; exit 0;;
    *) warn "Option inconnue: $1"; usage; exit 1;;
  esac
done

if [[ $STRICT -eq 1 && "$MATCH_CODES" == "all" ]]; then
  MATCH_CODES="200,301,302,401,403"
fi

command -v ffuf >/dev/null || { warn "ffuf manquant"; exit 1; }
command -v curl >/dev/null || { warn "curl manquant"; exit 1; }
command -v nmap >/dev/null || { warn "nmap manquant"; exit 1; }
command -v jq   >/dev/null || { warn "jq manquant (nécessaire pour parser le JSON ffuf)"; exit 1; }

ok "Domaine : ${DOMAIN}"

# ---------- Dossier mes_scans ----------
MES_SCANS_DIR="scans_subdomains"
mkdir -p "$MES_SCANS_DIR"
SCAN_FILE="${MES_SCANS_DIR}/scan_vhosts.txt"
ok "Fichier de résultats : ${SCAN_FILE}"

# ---------- Wordlist effective ----------
WL_EFFECTIVE=""
if [[ "$MODE" == "custom" ]]; then
  [[ -f "$WL" ]] || { warn "Wordlist custom introuvable : $WL"; exit 1; }
  WL_EFFECTIVE="$WL"
  ok "Mode : CUSTOM (wordlist: $WL_EFFECTIVE)"
else
  [[ -f "$MASTER" ]] || { warn "Wordlist master introuvable : $MASTER"; exit 1; }
  case "$MODE" in
    fast)   N=1000;;
    medium) N=2000;;
    large)  N=5000;;
  esac
  WL_EFFECTIVE="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_wl.XXXXXX")"
  head -n "$N" "$MASTER" > "$WL_EFFECTIVE"
  ok "Mode : $(echo "$MODE" | tr a-z A-Z)  (wordlist: $WL_EFFECTIVE)"
  info "Master : $MASTER"
fi

# ---------- Résolution IP ----------
TARGET_IP="$(getent hosts "$DOMAIN" | awk '{print $1}' | head -n1 || true)"
if [[ -z "$TARGET_IP" ]]; then
  TARGET_IP="$(dig +short A "$DOMAIN" 2>/dev/null | head -n1 || true)"
fi

if [[ -n "$TARGET_IP" ]]; then
  ok "IP détectée : $TARGET_IP"
else
  warn "IP non détectée pour ${DOMAIN}. Impossible de lancer un scan web."
  exit 1
fi

# ---------- Vérification ping ----------
if ping -c1 -W1 "$TARGET_IP" >/dev/null 2>&1; then
  ok "Ping OK : ${DOMAIN} (${TARGET_IP}) est joignable."
else
  warn "Ping échoué vers ${DOMAIN} (${TARGET_IP})."
  warn "Il est possible que l'entrée /etc/hosts soit obsolète (reset de machine HTB, nouvelle IP...)."
  echo
  read -r -p "Continuer quand même le scan ? [o/N] " rep
  case "$rep" in
    [oOyY]) info "Poursuite du scan malgré l'échec du ping." ;;
    *) warn "Scan interrompu."; exit 1 ;;
  esac
fi

# ---------- Scan Nmap interne ----------
NMAP_FILE="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_nmap.XXXXXX")"
_run_nmap_scan "$TARGET_IP" "$NMAP_FILE"

WEB_ENDPOINTS_RAW="$(detect_web_endpoints_from_nmap "$NMAP_FILE" || true)"
WEB_ENDPOINTS=()
if [[ -n "$WEB_ENDPOINTS_RAW" ]]; then
  mapfile -t WEB_ENDPOINTS <<< "$WEB_ENDPOINTS_RAW"
fi

DETAILS_TXT="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_details.XXXXXX")"
UNION_VHOSTS="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_union.XXXXXX")"
: > "$DETAILS_TXT"
: > "$UNION_VHOSTS"

if ((${#WEB_ENDPOINTS[@]} == 0)); then
  warn "Aucun service HTTP/HTTPS détecté par Nmap sur ${TARGET_IP}."
  echo "Aucun port HTTP/HTTPS détecté." >> "$DETAILS_TXT"
else
  info "Ports HTTP/HTTPS détectés : ${WEB_ENDPOINTS[*]}"

  for ep in "${WEB_ENDPOINTS[@]}"; do
    PORT="${ep%%:*}"
    SCHEME="${ep##*:}"

    # TLS flags
    CURL_TLS=(); FFUF_TLS=()
    [[ "$SCHEME" == "https" ]] && CURL_TLS+=(--insecure) && FFUF_TLS+=(-k)

    info "Port ${PORT} (${SCHEME}) : baselines…"

    read -r BH1 BC1 BS1 BW1 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 0)
    read -r BH2 BC2 BS2 BW2 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 0)
    read -r BH3 BC3 BS3 BW3 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 0)

    {
      echo "Port ${PORT} (${SCHEME})"
      echo "  Baseline#1: code=${BC1} size=${BS1} words=${BW1} (Host=${BH1}.${DOMAIN})"
      echo "  Baseline#2: code=${BC2} size=${BS2} words=${BW2} (Host=${BH2}.${DOMAIN})"
      echo "  Baseline#3: code=${BC3} size=${BS3} words=${BW3} (Host=${BH3}.${DOMAIN})"
    } >> "$DETAILS_TXT"

    if [[ "$BC1" == "000" && "$BC2" == "000" && "$BC3" == "000" ]]; then
      warn "Baselines invalides sur ${PORT} (code=000) → service non HTTP."
      {
        echo "  VHOST (0)"
        echo "    - (fuzzing sauté : baseline code=000)"
        echo
      } >> "$DETAILS_TXT"
      continue
    fi

    # Si 3xx stable : on suit les redirects (curl -L) et on fera ffuf -r
    FOLLOW_REDIRECTS=0
    REF_CODE="$BC1"; REF_SIZE="$BS1"; REF_WORDS="$BW1"
    if [[ "$BC1" =~ ^3 && "$BC2" =~ ^3 && "$BC3" =~ ^3 ]]; then
      FOLLOW_REDIRECTS=1
      info "Baseline 3xx détectée → baselines après redirection (curl -L) + ffuf -r"
      read -r _ LBC1 LBS1 LBW1 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 1)
      read -r _ LBC2 LBS2 LBW2 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 1)
      read -r _ LBC3 LBS3 LBW3 < <(_fetch_baseline_metrics "$SCHEME" "$TARGET_IP" "$PORT" "$DOMAIN" "$TIMEOUT" 1)
      {
        echo "  After-redirect#1: code=${LBC1} size=${LBS1} words=${LBW1}"
        echo "  After-redirect#2: code=${LBC2} size=${LBS2} words=${LBW2}"
        echo "  After-redirect#3: code=${LBC3} size=${LBS3} words=${LBW3}"
      } >> "$DETAILS_TXT"
      REF_CODE="$LBC1"; REF_SIZE="$LBS1"; REF_WORDS="$LBW1"
    fi

    # Wildcard probable (hors 3xx stable)
    if _is_wildcard_likely "$BC1" "$BS1" "$BW1" "$BC2" "$BS2" "$BW2" "$BC3" "$BS3" "$BW3"; then
      warn "Wildcard vhost probable sur ${PORT} (${SCHEME}) → fuzzing sauté pour éviter les faux positifs."
      {
        echo "  VHOST (0)"
        echo "    - (fuzzing sauté : wildcard probable)"
        echo
      } >> "$DETAILS_TXT"
      continue
    fi

    FFUF_FILTER=()
    [[ "$REF_SIZE"  != "0" ]] && FFUF_FILTER+=(-fs "$REF_SIZE")
    [[ "$REF_WORDS" != "0" ]] && FFUF_FILTER+=(-fw "$REF_WORDS")

    FFUF_AC=()
    if _needs_autocalibration "$BS1" "$BW1" "$BS2" "$BW2" "$BS3" "$BW3"; then
      FFUF_AC=(-ac)
      info "Réponse baseline instable → activation automatique de ffuf -ac"
    fi

    FFUF_R=()
    [[ "$FOLLOW_REDIRECTS" -eq 1 ]] && FFUF_R=(-r)

    FFUF_JSON="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_ffuf_${PORT}.XXXXXX.json")"
    FFUF_RAW="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_ffuf_${PORT}.XXXXXX.raw")"
    VHOST_TXT_PORT="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_vhosts_${PORT}.XXXXXX")"
    : > "$VHOST_TXT_PORT"

    info "VHOST fuzzing via ffuf sur ${SCHEME}://${TARGET_IP}:${PORT}/ ..."

    CMD=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}/" "${FFUF_TLS[@]}" "${FFUF_R[@]}"
              -H "Host: FUZZ.${DOMAIN}"
              -w "$WL_EFFECTIVE" -t "$THREADS"
              -mc "${MATCH_CODES}" "${FFUF_FILTER[@]}" "${FFUF_AC[@]}"
              -of json -o "$FFUF_JSON")

    if [[ $DEBUG -eq 1 ]]; then
      echo "[*] CMD: ${CMD[*]}"
      "${CMD[@]}" 2>&1 | tee "$FFUF_RAW" || true
    else
      "${CMD[@]}" || true
    fi

    # Extraction fiable via JSON (jq)
    extract_ffuf_json_to_vhosts "$FFUF_JSON" "$DOMAIN" > "$VHOST_TXT_PORT" || true
    VHOST_COUNT_PORT="$(grep -c '.' "$VHOST_TXT_PORT" 2>/dev/null || true)"
    VHOST_COUNT_PORT="${VHOST_COUNT_PORT:-0}"

    {
      echo "  VHOST (${VHOST_COUNT_PORT})"
      if [[ "$VHOST_COUNT_PORT" -gt 0 ]]; then
        sed 's/^/    - /' "$VHOST_TXT_PORT"
      else
        echo "    - (aucun)"
      fi
      echo
    } >> "$DETAILS_TXT"

    if [[ "$VHOST_COUNT_PORT" -gt 0 ]]; then
      cat "$VHOST_TXT_PORT" >> "$UNION_VHOSTS"
    fi
  done

  if [[ -s "$UNION_VHOSTS" ]]; then
    sort -u "$UNION_VHOSTS" -o "$UNION_VHOSTS"
  fi
fi

# total = unique (robuste, évite "0\n0")
if [[ -s "$UNION_VHOSTS" ]]; then
  VHOST_COUNT_TOTAL="$(wc -l < "$UNION_VHOSTS" | tr -d ' ')"
else
  VHOST_COUNT_TOTAL=0
fi

# ---------- /etc/hosts ----------
if [[ $SAVE_HOSTS -eq 1 || $DRY_RUN_HOSTS -eq 1 ]]; then
  if [[ "$VHOST_COUNT_TOTAL" -eq 0 ]]; then
    warn "Pas de vhost trouvé → rien à faire pour /etc/hosts."
  else
    if [[ $DRY_RUN_HOSTS -eq 1 ]]; then
      info "[DRY-RUN] Lignes qui seraient ajoutées à /etc/hosts :"
      while IFS= read -r host; do
        echo "${TARGET_IP} ${host}"
      done < "$UNION_VHOSTS"
    else
      TS="$(date +%Y%m%d-%H%M%S)"
      BACKUP="/etc/hosts.bak.${TS}"
      info "Sauvegarde: ${BACKUP}"
      if sudo cp /etc/hosts "$BACKUP"; then
        ADDED=0
        while IFS= read -r host; do
          if ! grep -qw "$host" /etc/hosts; then
            echo "${TARGET_IP} ${host}" | sudo tee -a /etc/hosts >/dev/null
            ((ADDED++))
          fi
        done < "$UNION_VHOSTS"
        [[ $ADDED -gt 0 ]] && ok "--save-hosts : ${ADDED} entrées ajoutées" || info "Aucun ajout (déjà présent)."
      else
        warn "Backup /etc/hosts échoué → abandon de --save-hosts."
      fi
    fi
  fi
fi

# ---------- Construction du bloc final & affichage ----------
BLOCK_START="=== mon-subdomains ${DOMAIN} START ==="
BLOCK_END="=== mon-subdomains ${DOMAIN} END ==="
TMP_BLOCK="$(mktemp "/tmp/mon-subdomains_${DOMAIN}_block.XXXXXX")"

{
  echo "$BLOCK_START"
  echo "Script       : mon-subdomains"
  echo "Version      : $(_version_str)"
  echo "Date         : $(date '+%F %T')"
  echo "Domaine      : ${DOMAIN}"
  echo "IP           : ${TARGET_IP}"
  echo "Mode         : ${MODE}"
  if [[ $DEBUG -eq 1 ]]; then
    echo "Wordlist eff.: $WL_EFFECTIVE"
  fi
  echo "Master       : ${MASTER}"
  echo "Codes        : ${MATCH_CODES}  (strict=${STRICT})"
  echo
  echo "VHOST totaux : ${VHOST_COUNT_TOTAL}"
  if [[ -s "$UNION_VHOSTS" ]]; then
    sed 's/^/  - /' "$UNION_VHOSTS"
  else
    echo "  - (aucun)"
  fi
  echo
  echo "--- Détails par port ---"
  cat "$DETAILS_TXT"
  echo
  if [[ $DEBUG -eq 1 ]]; then
    echo "--- Nmap interne ---"
    echo "  Fichier : $NMAP_FILE"
    echo
  fi
  echo
  echo "$BLOCK_END"
  echo
} > "$TMP_BLOCK"

echo
echo -e "${BLUE}===== Résultats mon-subdomains (${DOMAIN}) =====${RESET}"
cat "$TMP_BLOCK"
echo -e "${BLUE}===============================================${RESET}"
echo

# ---------- Insertion dans scan_vhosts.txt ----------
if [[ -f "$SCAN_FILE" ]]; then
  sed -e "/^=== mon-subdomains ${DOMAIN} START ===\$/,/^=== mon-subdomains ${DOMAIN} END ===\$/d" \
    "$SCAN_FILE" > "${SCAN_FILE}.tmp" || true
  mv "${SCAN_FILE}.tmp" "$SCAN_FILE"
fi
cat "$TMP_BLOCK" >> "$SCAN_FILE"
ok "Bloc mis à jour dans ${SCAN_FILE} pour le domaine ${DOMAIN}"

# ---------- Nettoyage ----------
if [[ $DEBUG -eq 1 ]]; then
  info "DEBUG MODE : aucun nettoyage des fichiers /tmp effectué."
  info "Fichiers temporaires conservés :"
  ls -1 /tmp/mon-subdomains_"${DOMAIN}"_* 2>/dev/null || true
else
  rm -f /tmp/mon-subdomains_"${DOMAIN}"_* 2>/dev/null || true
fi
exit 0
