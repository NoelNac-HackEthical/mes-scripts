#!/bin/bash
# NAME=mon-nouveau-recoweb
# VERSION=v1.6.0
# DESCRIPTION=Découverte web automatisée via feroxbuster + ffuf + dirsearch avec heuristique de bruit (ffuf) et agrégation des chemins filtrés.
# PRESENTATION_START
# mon-nouveau-recoweb — Découverte web ciblée pour CTF / pentest (feroxbuster + ffuf + dirsearch)
#
# Ce script automatise la reconnaissance web d'une cible (ex. mon-site.htb) en combinant :
#   - feroxbuster : scan récursif en premier, avec ses mécanismes internes (auto-filter, recursion, etc.),
#   - ffuf        : scan guidé par baseline + heuristique de bruit (404/403 génériques),
#   - dirsearch   : scan supplémentaire après ffuf, basé sur sa propre wordlist et sa config.
#
# Principales étapes :
# - Résolution du domaine vers une IP + vérification par ping (cohérence /etc/hosts).
# - Scan Nmap interne (-Pn -sV -p-) pour détecter tous les ports TCP exposant du HTTP/HTTPS.
# - Pour chaque port HTTP/HTTPS détecté :
#
#   1) Scan feroxbuster (en premier) :
#      - Lancement de feroxbuster sur l’URL basée sur le domaine (http(s)://domaine[:port]/chemin).
#      - Utilisation d’une wordlist dédiée (--ferox-master, défaut : big.txt).
#      - Aucune modification des paramètres internes de ferox (filtres, recursion, auto-filter).
#      - Conservation de la sortie dans un fichier pour extraction des chemins (/path).
#
#   2) Baseline + ffuf (en second) :
#      a) Calcul d’une baseline HTTP sur un chemin aléatoire :
#         - Requête vers http(s)://IP:PORT/<random> avec en-tête Host: domaine.
#         - Récupération du triplet : code HTTP, taille de réponse, nombre de mots.
#         - Utilisation de cette baseline pour paramétrer les filtres ffuf (-fs / -fw)
#           contre les faux positifs (404 génériques).
#
#      b) Phase d’échantillonnage (détection du bruit de fond) — ffuf uniquement :
#         - Construction d’une mini-wordlist (~10 000 premières entrées de la wordlist ffuf).
#         - Lancement d’un ffuf échantillon sur cette mini-wordlist, avec les filtres de baseline.
#         - Analyse des résultats CSV pour détecter les combos (status:size) récurrents typiques du bruit
#           (ex. 403:199 renvoyé massivement par le serveur).
#
#      c) Scan ffuf complet (sur la wordlist ffuf principale) :
#         - Lancement d’un ffuf sur l’ensemble de la wordlist ffuf (--ffuf-master),
#           en appliquant :
#             * les filtres de baseline (-fs, -fw),
#             * les filtres supplémentaires (-fs, -fw) dérivés des combos de bruit détectés à l’étape b).
#         - Export des résultats en CSV par port.
#         - Post-traitement côté script pour exclure explicitement les combos (status:size) identifiés comme bruit.
#
#   3) dirsearch (après ffuf) :
#      - Lancement de dirsearch sur l’URL basée sur le domaine.
#      - Utilisation de la configuration / wordlist par défaut de dirsearch.
#      - Extraction des chemins depuis le rapport texte.
#
#   4) Post-traitement et agrégation globale :
#      - Lecture de tous les chemins trouvés par feroxbuster, ffuf et dirsearch.
#      - Nettoyage :
#          * suppression des séquences ANSI,
#          * réduction des URLs complètes au chemin (/path),
#          * normalisation (suppression des / finaux, déduplication),
#          * conservation de la casse (LICENSE, README.md, etc.).
#      - Calcul :
#          * du nombre total de chemins bruts (ferox + ffuf + dirsearch, après filtrage),
#          * du nombre de chemins uniques normalisés.
#
# Wordlists par défaut :
#   - ffuf  : /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt
#   - ferox : /usr/share/seclists/Discovery/Web-Content/big.txt
#
# Résultats :
#   - Affichage à l’écran avec sections détaillées :
#       * Résumé global (ports HTTP/HTTPS, compteurs de chemins bruts / uniques).
#       * Résultats feroxbuster (par port).
#       * Résultats FFUF (par port).
#       * Résultats dirsearch (par port).
#   - Agrégation dans un fichier dans le répertoire mes_scans/ :
#       * Si on lance : mon-nouveau-recoweb target.htb
#           → mes_scans/scan_repertoires.txt
#       * Si on cible un sous-chemin : mon-nouveau-recoweb target.htb/cgi-bin/
#           → mes_scans/scan_repertoires_cgi-bin.txt
#
# PRESENTATION_END

set -euo pipefail
LC_ALL=C

# --- version helpers ---
_self_path="${BASH_SOURCE[0]:-$0}"
if command -v readlink >/dev/null 2>&1; then
  _resolved="$(readlink -f -- "$_self_path" 2>/dev/null || true)"
  [ -n "$_resolved" ] && _self_path="$_resolved"
fi
_self_base="$(basename "$_self_path")"

_version_str() {
  local v
  v="$(awk -F= '/^# *VERSION *=/ { gsub(/\r$/,"",$2); print $2; exit }' "$_self_path" 2>/dev/null || true)"
  [ -n "$v" ] || v="v0.0.0"
  printf "%s\n" "$v"
}

_print_version_and_exit() { _version_str; exit 0; }

# --- UI helpers ---
GREEN="\e[32m"; BLUE="\e[34m"; YELLOW="\e[33m"; RESET="\e[0m"
ok()   { echo -e "${GREEN}[✓]${RESET} $*"; }
info() { echo -e "${BLUE}[*]${RESET} $*"; }
warn() { echo -e "${YELLOW}[!]${RESET} $*"; }

usage(){
  cat <<'USAGE'
Usage:
  mon-nouveau-recoweb <domaine.htb> [options]

Options :
  --ffuf-master FILE    Wordlist ffuf (défaut: /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt)
  --ferox-master FILE   Wordlist feroxbuster (défaut: /usr/share/seclists/Discovery/Web-Content/big.txt)
  -t N                  Threads ffuf (défaut: 50)
  --timeout S           Timeout curl pour la baseline (défaut: 8)
  --strict              Mode strict (déjà activé par défaut : 200,301,302,403)
  --codes LIST          Liste pour ffuf -mc (ex: "200,301,302,403"; priorité sur --strict)
  --ext LIST            Extensions ffuf (ex: ".php,.txt,.sh,.cgi,.pl"). Vide = désactivé.
  --debug               Affiche les commandes ffuf/ferox/dirsearch et conserve les fichiers /tmp
  -V, --version         Afficher la version et quitter
  -h, --help            Aide

Exemples :
  mon-nouveau-recoweb target.htb
  mon-nouveau-recoweb target.htb/cgi-bin/ --ext ".sh,.cgi,.pl"
  mon-nouveau-recoweb target.htb --ffuf-master raft-large-directories.txt --ferox-master big.txt
USAGE
}

# ---------- parseur ffuf simple (non utilisé pour le filtrage bruit) ----------
extract_paths_csv() {
  local f="$1"
  [[ -f "$f" ]] || return 0

  awk -F',' '
    NR==1 { next }
    {
      for (i=1; i<=NF; i++) {
        if (match($i, /(https?:\/\/[^\/]+(\/[^"]*))/ , m)) {
          path = m[2]
          if (path == "" || path == "/") next
          print path
          break
        }
      }
    }
  ' "$f" | sort -u
}

# ---------- détecter les combos (status:size) "bruit" dans un CSV ffuf ----------
detect_ffuf_noise_combos() {
  local f="$1"
  [[ -f "$f" ]] || return 0

  awk -F',' '
    NR==1 {
      for (i=1; i<=NF; i++) {
        h=$i; gsub(/"/,"",h); h=tolower(h)
        if (h ~ /status/)                                      ci_status=i
        else if (h ~ /content[_-]*length/ || h ~ /length/ || h ~ /size/) ci_size=i
      }
      next
    }
    {
      if (!ci_status || !ci_size) {
        next
      }
      total++
      code = $ci_status+0
      size = $ci_size+0
      key  = code ":" size
      count[key]++
    }
    END {
      if (total == 0) exit
      # Heuristique : toute combo 403:SIZE qui apparaît au moins 5 fois = bruit
      for (k in count) {
        split(k,a,":")
        code=a[1]; size=a[2]
        c=count[k]
        if (code == 403 && c >= 5) {
          print k
        }
      }
    }
  ' "$f"
}

# ---------- extraire les paths ffuf en ignorant les combos "bruit" détectés ----------
filtered_paths_from_ffuf_csv() {
  local f="$1"
  local noise_file="$2"

  [[ -f "$f" ]] || return 0

  awk -F',' '
    # 1er fichier : fichier de combos de bruit (status:size)
    FNR==NR {
      line=$0
      gsub(/^[ \t\r\n]+|[ \t\r\n]+$/, "", line)
      if (line != "") {
        noise[line]=1
      }
      next
    }

    # 2e fichier : CSV ffuf
    FNR==1 {
      # Détection des colonnes
      for (i=1; i<=NF; i++) {
        h=$i; gsub(/"/,"",h); h=tolower(h)
        if (h ~ /status/)                                      ci_status=i
        else if (h ~ /content[_-]*length/ || h ~ /length/ || h ~ /size/) ci_size=i
        else if (h=="url")                                     ci_url=i
      }
      next
    }

    {
      if (!ci_status || !ci_size || !ci_url) {
        next
      }

      code = $ci_status+0
      size = $ci_size+0
      key  = code ":" size

      # Si le couple (status:size) est marqué comme bruit → on ignore
      if (key in noise) {
        next
      }

      url = $ci_url
      # Nettoyage des séquences ANSI éventuelles
      gsub(/\x1B\[[0-9;]*[A-Za-z]/, "", url)

      if (match(url, /(https?:\/\/[^\/]+(\/[^"]*))/ , m)) {
        path = m[2]
        if (path=="" || path=="/") next
        print path
      }
    }
  ' "$noise_file" "$f" | sort -u
}

# ---------- extraction des paths depuis la sortie dirsearch / ferox ----------
extract_paths_dirsearch() {
  local f="$1"
  [[ -f "$f" ]] || return 0

  awk '
    {
      line=$0
      # Nettoyage ANSI
      gsub(/\x1B\[[0-9;]*[A-Za-z]/, "", line)
      if (match(line, /(https?:\/\/[^\/]+(\/[^[:space:]]*))/ , m)) {
        path = m[2]
        if (path == "" || path == "/") next
        print path
      }
    }
  ' "$f" | sort -u
}

# ---------- détection des endpoints HTTP/HTTPS à partir d'un Nmap -sV ----------
detect_web_endpoints_from_nmap() {
  local nmap_file="$1"
  [[ -f "$nmap_file" ]] || return 1

  local endpoints=()
  local line port svc rest text scheme

  while IFS= read -r line; do
    if [[ "$line" =~ ^([0-9]+)/tcp[[:space:]]+open[[:space:]]+([^[:space:]]+)[[:space:]]*(.*)$ ]]; then
      port="${BASH_REMATCH[1]}"
      svc="${BASH_REMATCH[2]}"
      rest="${BASH_REMATCH[3]}"
      text="${svc} ${rest}"
      if grep -qi 'http' <<<"$text"; then
        scheme="http"
        if grep -qiE 'https|ssl/http|tls' <<<"$text"; then
          scheme="https"
        fi
        endpoints+=("${port}:${scheme}")
      fi
    fi
  done < "$nmap_file"

  ((${#endpoints[@]}==0)) && return 1
  printf '%s\n' "${endpoints[@]}" | sort -n | uniq
}

# ---------- Version / aide ----------
if [[ "${1-}" == "-V" || "${1-}" == "--version" ]]; then
  _print_version_and_exit
fi

if [[ "${1-}" == "-h" || "${1-}" == "--help" || -z "${1-}" ]]; then
  usage
  exit 0
fi

# ---------- Arguments ----------
DOMAIN="${1-}"
shift || true

HOST="${DOMAIN%%/*}"
HOST="${HOST%%:*}"
[[ -z "$HOST" ]] && HOST="$DOMAIN"

PATH_PART=""
if [[ "$DOMAIN" == */* ]]; then
  PATH_PART="${DOMAIN#*/}"
  PATH_PART="/${PATH_PART}"
  [[ "$PATH_PART" != */ ]] && PATH_PART="${PATH_PART}/"
fi

if [[ -z "$PATH_PART" ]]; then
  PATH_PART="/"
fi

MODE="standard"
THREADS=50
TIMEOUT=8

FFUF_MASTER="/usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt"
FEROX_MASTER="/usr/share/seclists/Discovery/Web-Content/big.txt"

STRICT=1
MATCH_CODES="200,301,302,403"
DEBUG=0

EXTENSIONS_DEFAULT=".php,.txt,"
EXTENSIONS="$EXTENSIONS_DEFAULT"

HAS_FEROX=0
HAS_DIRSEARCH=0

while (( "$#" )); do
  case "$1" in
    --ffuf-master)   FFUF_MASTER="${2-}"; shift 2;;
    --ferox-master)  FEROX_MASTER="${2-}"; shift 2;;
    -t)              THREADS="${2-}"; shift 2;;
    --timeout)       TIMEOUT="${2-}"; shift 2;;
    --strict)        STRICT=1; shift;;
    --codes)         MATCH_CODES="${2-}"; shift 2;;
    --ext)           EXTENSIONS="${2-}"; shift 2;;
    --debug)         DEBUG=1; shift;;
    -V|--version)    _print_version_and_exit ;;
    -h|--help)       usage; exit 0;;
    *)               warn "Option inconnue: $1"; usage; exit 1;;
  esac
done

# --- binaires nécessaires ---
# --- binaires nécessaires ---
# curl / nmap / ffuf sont critiques → on arrête si l'un manque
MISSING_CRIT=0

if ! command -v curl >/dev/null 2>&1; then
  warn "curl manquant. Installe-le avec : sudo apt install curl"
  MISSING_CRIT=1
fi

if ! command -v nmap >/dev/null 2>&1; then
  warn "nmap manquant. Installe-le avec : sudo apt install nmap"
  MISSING_CRIT=1
fi

if ! command -v ffuf >/dev/null 2>&1; then
  warn "ffuf manquant. Installe-le (Kali/Debian) avec : sudo apt install ffuf"
  MISSING_CRIT=1
fi

if [[ $MISSING_CRIT -eq 1 ]]; then
  warn "Un ou plusieurs binaires essentiels (curl/nmap/ffuf) sont manquants. Abandon du scan."
  exit 1
fi

# feroxbuster et dirsearch sont optionnels, on active/désactive dynamiquement
if command -v feroxbuster >/dev/null 2>&1; then
  HAS_FEROX=1
  info "feroxbuster détecté : il sera exécuté avant ffuf."
else
  HAS_FEROX=0
  warn "feroxbuster non détecté (optionnel). Installe-le avec : sudo apt install feroxbuster"
fi

if command -v dirsearch >/dev/null 2>&1; then
  HAS_DIRSEARCH=1
  info "dirsearch détecté : il sera exécuté après ffuf."
else
  HAS_DIRSEARCH=0
  warn "dirsearch non détecté (optionnel). Installe-le avec : sudo apt install dirsearch"
fi

ok "Domaine : ${DOMAIN}"

MES_SCANS_DIR="mes_scans"
mkdir -p "$MES_SCANS_DIR"

SCAN_FILE="${MES_SCANS_DIR}/scan_repertoires.txt"
if [[ -n "$PATH_PART" ]]; then
  PATH_TAG="${PATH_PART#/}"
  PATH_TAG="${PATH_TAG%/}"
  PATH_TAG="${PATH_TAG//\//-}"
  if [[ -n "$PATH_TAG" ]]; then
    SCAN_FILE="${MES_SCANS_DIR}/scan_repertoires_${PATH_TAG}.txt"
  fi
fi

ok "Fichier de résultats : ${SCAN_FILE}"

# --- Wordlists ffuf / ferox ---
FFUF_WL_EFFECTIVE="$FFUF_MASTER"
if [[ ! -f "$FFUF_WL_EFFECTIVE" ]]; then
  warn "Wordlist ffuf introuvable : $FFUF_WL_EFFECTIVE"
  warn "Installe le paquet 'seclists' (Kali/Debian) : sudo apt install seclists"
  echo "Ou spécifie une wordlist ffuf avec : --ffuf-master /chemin/vers/ta_wordlist.txt"
  exit 1
fi
ok "Wordlist ffuf  : $FFUF_WL_EFFECTIVE"

FEROX_WL_EFFECTIVE=""
if (( HAS_FEROX )); then
  FEROX_WL_EFFECTIVE="$FEROX_MASTER"
  if [[ ! -f "$FEROX_WL_EFFECTIVE" ]]; then
    warn "Wordlist ferox introuvable : $FEROX_WL_EFFECTIVE"
    warn "Elle fait typiquement partie du paquet 'seclists'. Exemple :"
    echo "  sudo apt install seclists"
    echo "feroxbuster sera désactivé pour ce run."
    HAS_FEROX=0
  else
    ok "Wordlist ferox : $FEROX_WL_EFFECTIVE"
  fi
fi

# --- Résumé de la chaîne de scans active ---
SCAN_CHAIN="Nmap"
if (( HAS_FEROX )); then
  SCAN_CHAIN+=" -> feroxbuster"
fi
SCAN_CHAIN+=" -> ffuf"
if (( HAS_DIRSEARCH )); then
  SCAN_CHAIN+=" -> dirsearch"
fi

info "Chaîne de scans active : ${SCAN_CHAIN}"

TARGET_IP="$(getent hosts "$HOST" | awk '{print $1}' | head -n1 || true)"
if [[ -z "$TARGET_IP" ]]; then
  TARGET_IP="$(dig +short A "$HOST" 2>/dev/null | head -n1 || true)"
fi

BLOCK_START="=== mon-nouveau-recoweb ${DOMAIN} START ==="
BLOCK_END="=== mon-nouveau-recoweb ${DOMAIN} END ==="

if [[ -z "$TARGET_IP" ]]; then
  TMP_BLOCK="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_block.XXXXXX")"
  {
    echo "$BLOCK_START"
    echo "Script       : mon-nouveau-recoweb"
    echo "Version      : $(_version_str)"
    echo "Date         : $(date '+%F %T')"
    echo "Domaine      : ${DOMAIN}"
    echo "IP           : (non détectée)"
    echo "Mode         : ${MODE}"
    echo "Wordlist ffuf  : ${FFUF_WL_EFFECTIVE}"
    if (( HAS_FEROX )); then
      echo "Wordlist ferox : ${FEROX_WL_EFFECTIVE}"
    else
      echo "Wordlist ferox : (désactivée ou introuvable)"
    fi
    echo "Codes ffuf     : ${MATCH_CODES}  (strict=${STRICT})"
    echo "Extensions     : ${EXTENSIONS:-"(désactivées)"}"
    echo "feroxbuster    : $([[ $HAS_FEROX -eq 1 ]] && echo 'activé' || echo 'désactivé')"
    echo "dirsearch      : $([[ $HAS_DIRSEARCH -eq 1 ]] && echo 'actif' || echo 'non installé / non détecté')"
    echo
    echo "Aucun port HTTP/HTTPS n'a pu être scanné (IP non détectée)."
    echo
    echo "$BLOCK_END"
    echo
  } > "$TMP_BLOCK"

  echo
  echo -e "${BLUE}===== Résultats mon-nouveau-recoweb (${DOMAIN}) =====${RESET}"
  cat "$TMP_BLOCK"
  echo -e "${BLUE}=============================================${RESET}"
  echo

  if [[ -f "$SCAN_FILE" ]]; then
    sed -e "\#^=== mon-nouveau-recoweb ${DOMAIN} START ===\$#,\#^=== mon-nouveau-recoweb ${DOMAIN} END ===\$#d" \
      "$SCAN_FILE" > "${SCAN_FILE}.tmp" || true
    mv "${SCAN_FILE}.tmp" "$SCAN_FILE"
  fi
  cat "$TMP_BLOCK" >> "$SCAN_FILE"
  ok "Bloc mis à jour dans ${SCAN_FILE} pour le domaine ${DOMAIN}"

  rm -f /tmp/mon-nouveau-recoweb_"${DOMAIN//\//_}"_* 2>/dev/null || true
  exit 0
fi

ok "IP détectée : $TARGET_IP"

if ping -c1 -W1 "$TARGET_IP" >/dev/null 2>&1; then
  ok "Ping OK : ${HOST} (${TARGET_IP}) est joignable."
else
  warn "Ping échoué vers ${HOST} (${TARGET_IP})."
  warn "Il est possible que l'entrée /etc/hosts soit obsolète (reset de machine HTB, nouvelle IP...)."
  echo
  read -r -p "Continuer quand même le scan ? [o/N] " rep
  case "$rep" in
    [oOyY]) info "Poursuite du scan malgré l'échec du ping." ;;
    *)      warn "Scan interrompu. Vérifie /etc/hosts puis relance mon-nouveau-recoweb."
            rm -f /tmp/mon-nouveau-recoweb_"${DOMAIN//\//_}"_* 2>/dev/null || true
            exit 1 ;;
  esac
fi

NMAP_FILE="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_nmap.XXXXXX")"
info "Scan Nmap interne pour détecter les ports HTTP/HTTPS…"
info "Commande : nmap -Pn -sV -p- --min-rate 5000 -T4 --max-retries 3 -oN \"$NMAP_FILE\" \"$TARGET_IP\""

if ! nmap -Pn -sV -p- --min-rate 5000 -T4 --max-retries 3 -oN "$NMAP_FILE" "$TARGET_IP"; then
  warn "Échec du scan Nmap interne sur ${TARGET_IP}."
fi

WEB_ENDPOINTS_RAW="$(detect_web_endpoints_from_nmap "$NMAP_FILE" || true)"
WEB_ENDPOINTS=()
if [[ -n "$WEB_ENDPOINTS_RAW" ]]; then
  mapfile -t WEB_ENDPOINTS <<< "$WEB_ENDPOINTS_RAW"
fi

FFUF_DETAILS="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ffuf_details.XXXXXX")"
DIRSEARCH_DETAILS="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirsearch_details.XXXXXX")"
FEROX_DETAILS="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ferox_details.XXXXXX")"
: > "$FFUF_DETAILS"
: > "$DIRSEARCH_DETAILS"
: > "$FEROX_DETAILS"

UNION_DIRS="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_union.XXXXXX")"
: > "$UNION_DIRS"
UNION_DIRS_NORM=""
DIR_COUNT_TOTAL=0
DIR_UNIQUE_TOTAL=0

if ((${#WEB_ENDPOINTS[@]} == 0)); then
  warn "Aucun service HTTP/HTTPS détecté par Nmap sur ${TARGET_IP}."
  echo "Aucun port HTTP/HTTPS détecté sur ${TARGET_IP}." >> "$FFUF_DETAILS"
  echo "Aucun port HTTP/HTTPS détecté sur ${TARGET_IP}." >> "$DIRSEARCH_DETAILS"
  echo "Aucun port HTTP/HTTPS détecté sur ${TARGET_IP}." >> "$FEROX_DETAILS"
else
  info "Ports HTTP/HTTPS détectés : ${WEB_ENDPOINTS[*]}"

  for ep in "${WEB_ENDPOINTS[@]}"; do
    PORT="${ep%%:*}"
    SCHEME="${ep##*:}"
    CURL_TLS=""; FFUF_TLS=""
    if [[ "$SCHEME" == "https" ]]; then
      CURL_TLS="--insecure"
      FFUF_TLS="-k"
    fi

    DIR_TXT_PORT_FFUF=""
    DIR_COUNT_PORT_FFUF=0
    DIR_TXT_PORT_FEROX=""
    DIR_COUNT_PORT_FEROX=0

    # =====================
    # 1) feroxbuster (en premier)
    # =====================
    if (( HAS_FEROX )); then
      FEROX_URL_BASE="${SCHEME}://${HOST}"
      if [[ "$SCHEME" == "http" && "$PORT" != "80" ]] || [[ "$SCHEME" == "https" && "$PORT" != "443" ]]; then
        FEROX_URL_BASE="${FEROX_URL_BASE}:${PORT}"
      fi
      FEROX_URL="${FEROX_URL_BASE}${PATH_PART}"

      FEROX_OUT="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ferox_${PORT}.out.XXXXXX")"
      DIR_TXT_PORT_FEROX="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirs_ferox_${PORT}.XXXXXX")"
      : > "$DIR_TXT_PORT_FEROX"

      FEROX_CMD=(feroxbuster
        -u "$FEROX_URL"
        -w "$FEROX_WL_EFFECTIVE"
        -o "$FEROX_OUT"
      )

      [[ $DEBUG -eq 1 ]] && echo "[*] CMD (feroxbuster): ${FEROX_CMD[*]}"
      "${FEROX_CMD[@]}" || true

      extract_paths_dirsearch "$FEROX_OUT" > "$DIR_TXT_PORT_FEROX" || true
      DIR_COUNT_PORT_FEROX="$(grep -c '.' "$DIR_TXT_PORT_FEROX" || true)"

      {
        echo "Port ${PORT} (${SCHEME})"
        echo "  Base ferox: ${FEROX_URL}"
        echo "  ferox DIR (${DIR_COUNT_PORT_FEROX})"
        if [[ "$DIR_COUNT_PORT_FEROX" -gt 0 ]]; then
          sed 's/^/    - /' "$DIR_TXT_PORT_FEROX"
        else
          echo "    - (aucun)"
        fi
        echo
      } >> "$FEROX_DETAILS"

      if [[ "$DIR_COUNT_PORT_FEROX" -gt 0 ]]; then
        cat "$DIR_TXT_PORT_FEROX" >> "$UNION_DIRS"
        DIR_COUNT_TOTAL=$((DIR_COUNT_TOTAL + DIR_COUNT_PORT_FEROX))
      fi
    fi

    # =====================
    # 2) Baseline + ffuf (en second)
    # =====================

    RAND_PATH="$(tr -dc 'a-z0-9' </dev/urandom | head -c 10 || echo rnd)"
    BASE_URL="${SCHEME}://${TARGET_IP}:${PORT}${PATH_PART}${RAND_PATH}"

    BASE_RESP="$(curl -sk ${CURL_TLS:-} -H "Host: ${HOST}" --max-time "$TIMEOUT" \
                   -o /dev/null -w "%{http_code} %{size_download}" "$BASE_URL" 2>/dev/null || true)"
    BASE_CODE="${BASE_RESP%% *}"; BASE_CODE="${BASE_CODE:-000}"
    BASE_SIZE="${BASE_RESP##* }"; BASE_SIZE="${BASE_SIZE:-0}"
    BASE_WORDS="$(curl -sk ${CURL_TLS:-} -H "Host: ${HOST}" --max-time "$TIMEOUT" \
                   "${SCHEME}://${TARGET_IP}:${PORT}${PATH_PART}${RAND_PATH}" 2>/dev/null | wc -w | tr -d ' ' || echo 0)"
    BASE_WORDS="${BASE_WORDS:-0}"

    FFUF_FILTER_BASE=()
    FFUF_AC_OPTS=()

    if [[ "$BASE_CODE" == "000" ]]; then
      warn "Baseline invalide sur le port ${PORT} (code=000) → ffuf sans filtres baseline."
      FFUF_AC_OPTS=(-ac)
    else
      [[ "$BASE_SIZE"  != "0" && -n "$BASE_SIZE"  ]] && FFUF_FILTER_BASE+=(-fs "$BASE_SIZE")
      [[ "$BASE_WORDS" != "0" && -n "$BASE_WORDS" ]] && FFUF_FILTER_BASE+=(-fw "$BASE_WORDS")
    fi

    info "Tentative d'élimination du bruit de fond (404/403 génériques) sur le port ${PORT} (échantillon ~10000 entrées, ffuf)…"
    info "Recherche des combos de bruit (status:size) dans les résultats ffuf du port ${PORT} (phase d'échantillonnage)..."

    WL_NOISE="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_wl_noise_${PORT}.XXXXXX")"
    head -n 10000 "$FFUF_WL_EFFECTIVE" > "$WL_NOISE" 2>/dev/null || cp "$FFUF_WL_EFFECTIVE" "$WL_NOISE"

    FFUF_CSV_NOISE="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ffuf_noise_${PORT}.csv.XXXXXX")"
    NOISE_KEYS_FILE="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ffuf_noise_keys_${PORT}.XXXXXX")"

    FFUF_EXT_OPTS=()
    if [[ -n "${EXTENSIONS:-}" ]]; then
      FFUF_EXT_OPTS=(-e "$EXTENSIONS")
    fi

    CMD_NOISE=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}${PATH_PART}FUZZ" $FFUF_TLS \
                     -H "Host: ${HOST}" \
                     -w "$WL_NOISE" -t "$THREADS" \
                     -mc "${MATCH_CODES}" \
                     "${FFUF_EXT_OPTS[@]}" \
                     -ic \
                     "${FFUF_AC_OPTS[@]}" \
                     "${FFUF_FILTER_BASE[@]}" \
                     -of csv -o "$FFUF_CSV_NOISE")

    [[ $DEBUG -eq 1 ]] && echo "[*] CMD_NOISE (ffuf): ${CMD_NOISE[*]}"
    "${CMD_NOISE[@]}" || true

    detect_ffuf_noise_combos "$FFUF_CSV_NOISE" > "$NOISE_KEYS_FILE" || true

    NOISE_SIZE=""
    if [[ -s "$NOISE_KEYS_FILE" ]]; then
      info "Heuristique bruit (ffuf) : combos détectés sur l'échantillon du port ${PORT} :"
      sed 's/^/    - /' "$NOISE_KEYS_FILE"
      while IFS= read -r combo; do
        size="${combo##*:}"
        if [[ -n "$size" ]]; then
          NOISE_SIZE="$size"
          break
        fi
      done < "$NOISE_KEYS_FILE"
    else
      info "Heuristique bruit (ffuf) : aucun combo de bruit de fond détecté sur l'échantillon du port ${PORT}."
    fi

    FFUF_FILTER_MAIN=()
    if [[ -n "$NOISE_SIZE" ]]; then
      [[ "$BASE_WORDS" != "0" && -n "$BASE_WORDS" ]] && FFUF_FILTER_MAIN+=(-fw "$BASE_WORDS")
      FFUF_FILTER_MAIN+=(-fs "$NOISE_SIZE")
    else
      FFUF_FILTER_MAIN=("${FFUF_FILTER_BASE[@]}")
    fi

    FFUF_CSV="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_ffuf_${PORT}.csv.XXXXXX")"
    DIR_TXT_PORT_FFUF="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirs_ffuf_${PORT}.XXXXXX")"
    : > "$DIR_TXT_PORT_FFUF"

    info "Fuzzing répertoires via ffuf sur ${SCHEME}://${TARGET_IP}:${PORT}${PATH_PART}FUZZ ..."

    CMD=(ffuf -u "${SCHEME}://${TARGET_IP}:${PORT}${PATH_PART}FUZZ" $FFUF_TLS \
              -H "Host: ${HOST}" \
              -w "$FFUF_WL_EFFECTIVE" -t "$THREADS" \
              -mc "${MATCH_CODES}" \
              "${FFUF_EXT_OPTS[@]}" \
              -ic \
              "${FFUF_AC_OPTS[@]}" \
              "${FFUF_FILTER_MAIN[@]}" \
              -of csv -o "$FFUF_CSV")

    [[ $DEBUG -eq 1 ]] && echo "[*] CMD (ffuf): ${CMD[*]}"
    "${CMD[@]}" || true

    filtered_paths_from_ffuf_csv "$FFUF_CSV" "$NOISE_KEYS_FILE" > "$DIR_TXT_PORT_FFUF" || true
    DIR_COUNT_PORT_FFUF="$(grep -c '.' "$DIR_TXT_PORT_FFUF" || true)"

    {
      echo "Port ${PORT} (${SCHEME})"
      echo "  Baseline: code=${BASE_CODE} size=${BASE_SIZE} words=${BASE_WORDS} (${PATH_PART}${RAND_PATH})"
      if [[ -s "$NOISE_KEYS_FILE" ]]; then
        echo "  Heuristique bruit (ffuf) : combos ignorés (status:size) :"
        sed 's/^/    - /' "$NOISE_KEYS_FILE"
      fi
      echo "  FFUF DIR (${DIR_COUNT_PORT_FFUF})"
      if [[ "$DIR_COUNT_PORT_FFUF" -gt 0 ]]; then
        sed 's/^/    - /' "$DIR_TXT_PORT_FFUF"
      else
        echo "    - (aucun)"
      fi
      echo
    } >> "$FFUF_DETAILS"

    if [[ "$DIR_COUNT_PORT_FFUF" -gt 0 ]]; then
      cat "$DIR_TXT_PORT_FFUF" >> "$UNION_DIRS"
      DIR_COUNT_TOTAL=$((DIR_COUNT_TOTAL + DIR_COUNT_PORT_FFUF))
    fi

    # =====================
    # 3) dirsearch (apres ffuf)
    # =====================
    if (( HAS_DIRSEARCH )); then
      # URL bassee sur le domaine, comme pour ferox
      DIR_URL_BASE="${SCHEME}://${HOST}"
      if { [[ "$SCHEME" == "http" && "$PORT" != "80" ]] || [[ "$SCHEME" == "https" && "$PORT" != "443" ]]; }; then
        DIR_URL_BASE="${DIR_URL_BASE}:${PORT}"
      fi
      DIR_URL="${DIR_URL_BASE}${PATH_PART}"

      DIR_OUT="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirsearch_${PORT}.out.XXXXXX")"
      DIR_TXT_PORT_DIR="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirs_dirsearch_${PORT}.XXXXXX")"
      : > "$DIR_TXT_PORT_DIR"

      # Workdir temporaire pour contenir eventuels reports/
      DIR_TMP_WORKDIR="$(mktemp -d "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_dirsearch_work.${PORT}.XXXXXX")"

      # Commande dirsearch (forme tableau pour eviter les soucis d'espaces)
      DIR_CMD=(dirsearch -u "$DIR_URL")

      if command -v script >/dev/null 2>&1; then
        # Progress bar propre grace a un pseudo-TTY
        if [[ $DEBUG -eq 1 ]]; then
          echo "[*] CMD (dirsearch via script): (cd \"$DIR_TMP_WORKDIR\" && script -q -c '${DIR_CMD[*]}' '$DIR_OUT')"
        fi
        (
          cd "$DIR_TMP_WORKDIR" || exit 0
          script -q -c "${DIR_CMD[*]}" "$DIR_OUT" </dev/null || true
        )
      else
        # Fallback: progress un peu moins jolie, mais sortie capturee
        if [[ $DEBUG -eq 1 ]]; then
          echo "[*] CMD (dirsearch via tee): (cd \"$DIR_TMP_WORKDIR\" && ${DIR_CMD[*]} | tee '$DIR_OUT')"
        fi
        (
          cd "$DIR_TMP_WORKDIR" || exit 0
          "${DIR_CMD[@]}" 2>/dev/null | tee "$DIR_OUT" || true
        )
      fi

      # Extraction des chemins depuis la sortie texte de dirsearch
      extract_paths_dirsearch "$DIR_OUT" > "$DIR_TXT_PORT_DIR" || true
      DIR_COUNT_PORT_DIR="$(grep -c '.' "$DIR_TXT_PORT_DIR" || true)"

      {
        echo "Port ${PORT} (${SCHEME})"
        echo "  dirsearch :"
        echo "    DIR (${DIR_COUNT_PORT_DIR})"
        if [[ "$DIR_COUNT_PORT_DIR" -gt 0 ]]; then
          sed 's/^/      - /' "$DIR_TXT_PORT_DIR"
        else
          echo "      - (aucun)"
        fi
        echo
      } >> "$DIRSEARCH_DETAILS"

      # Ajout au set global
      if [[ "$DIR_COUNT_PORT_DIR" -gt 0 ]]; then
        cat "$DIR_TXT_PORT_DIR" >> "$UNION_DIRS"
        DIR_COUNT_TOTAL=$((DIR_COUNT_TOTAL + DIR_COUNT_PORT_DIR))
      fi

      # Nettoyage complet du workdir (y compris reports/)
      rm -rf "$DIR_TMP_WORKDIR" 2>/dev/null || true

    else
      {
        echo "Port ${PORT} (${SCHEME})"
        echo "  dirsearch :"
        echo "    (dirsearch non installe / non detecte ou desactive)"
        echo
      } >> "$DIRSEARCH_DETAILS"
    fi

  done

  if [[ -s "$UNION_DIRS" ]]; then
    sort -u "$UNION_DIRS" -o "$UNION_DIRS"

    UNION_DIRS_NORM="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_union_norm.XXXXXX")"
    awk '
      {
        s = $0
        # Nettoyage ANSI (progress bar, etc.)
        gsub(/\x1B\[[0-9;]*[A-Za-z]/, "", s)

        # Si on voit une URL complète, extraire juste le /chemin
        if (match(s, /(https?:\/\/[^\/]+(\/[^[:space:]]*))/ , m)) {
          s = m[2]
        } else {
          sub(/^[^\/]*/, "", s)
        }

        if (s == "" || s !~ /^\//) next

        # Supprimer les / finaux multiples
        gsub(/\/+$/, "", s)

        if (s == "" || s == ".") next

        # On conserve la casse originale
        print s
      }
    ' "$UNION_DIRS" | sort -u > "$UNION_DIRS_NORM"

    DIR_UNIQUE_TOTAL="$(grep -c . "$UNION_DIRS_NORM" || true)"
  else
    DIR_UNIQUE_TOTAL=0
  fi
fi

TMP_BLOCK="$(mktemp "/tmp/mon-nouveau-recoweb_${DOMAIN//\//_}_block.XXXXXX")"

# Préparer les sections ferox / ffuf / dirsearch
FEROX_SECTION_BODY=""
FFUF_SECTION_BODY=""
DIRSEARCH_SECTION_BODY="  (dirsearch non installé / non détecté ou désactivé)"

if (( HAS_FEROX )) && [[ -s "$FEROX_DETAILS" ]]; then
  FEROX_SECTION_BODY="$(cat "$FEROX_DETAILS")"
else
  FEROX_SECTION_BODY="  (feroxbuster non utilisé pour ce scan ou aucun résultat)"
fi

if [[ -s "$FFUF_DETAILS" ]]; then
  FFUF_SECTION_BODY="$(cat "$FFUF_DETAILS")"
else
  FFUF_SECTION_BODY="  (ffuf non utilisé pour ce scan ou aucun résultat)"
fi

if [[ -s "$DIRSEARCH_DETAILS" ]]; then
  DIRSEARCH_SECTION_BODY="$(cat "$DIRSEARCH_DETAILS")"
fi

{
  echo "$BLOCK_START"
  echo "Script         : mon-nouveau-recoweb"
  echo "Version        : $(_version_str)"
  echo "Date           : $(date '+%F %T')"
  echo "Domaine        : ${DOMAIN}"
  echo "IP             : ${TARGET_IP}"
  echo "Mode           : ${MODE}"
  echo "Wordlist ffuf  : ${FFUF_WL_EFFECTIVE}"

  if (( HAS_FEROX )); then
    echo "Wordlist ferox : ${FEROX_WL_EFFECTIVE}"
  else
    echo "Wordlist ferox : (désactivée ou introuvable)"
  fi

  echo "Codes ffuf     : ${MATCH_CODES}  (strict=${STRICT})"
  echo "Extensions     : ${EXTENSIONS:-"(désactivées)"}"

  if (( HAS_FEROX )); then
    echo "feroxbuster    : actif"
  else
    echo "feroxbuster    : désactivé"
  fi

  if (( HAS_DIRSEARCH )); then
    echo "dirsearch      : actif (exécuté après ffuf)"
  else
    echo "dirsearch      : non installé / non détecté"
  fi
  echo

  echo "=== Résumé global ==="
  if ((${#WEB_ENDPOINTS[@]} > 0)); then
    echo "Ports HTTP/HTTPS détectés : ${WEB_ENDPOINTS[*]}"
  else
    echo "Ports HTTP/HTTPS détectés : (aucun)"
  fi

  echo "Total chemins bruts (ferox/ffuf/dirsearch, après filtrage) : ${DIR_COUNT_TOTAL}"
  echo "Chemins uniques normalisés                                 : ${DIR_UNIQUE_TOTAL}"
  echo
  echo "Chemins uniques :"

  if [[ -n "$UNION_DIRS_NORM" && -s "$UNION_DIRS_NORM" ]]; then
    sed 's/^/  - /' "$UNION_DIRS_NORM"
  else
    echo "  - (aucun)"
  fi

  echo
  echo "=== Résultats feroxbuster (par port) ==="
  printf "%s\n" "$FEROX_SECTION_BODY"
  echo

  echo "=== Résultats FFUF (par port) ==="
  printf "%s\n" "$FFUF_SECTION_BODY"
  echo

  echo "=== Résultats dirsearch (par port) ==="
  printf "%s\n" "$DIRSEARCH_SECTION_BODY"
  echo

  echo "$BLOCK_END"
  echo
} > "$TMP_BLOCK"

echo
echo -e "${BLUE}===== Résultats mon-nouveau-recoweb (${DOMAIN}) =====${RESET}"
cat "$TMP_BLOCK"
echo -e "${BLUE}=============================================${RESET}"
echo

# Mise à jour du fichier scan_repertoires*.txt

if [[ -f "$SCAN_FILE" ]]; then
  sed -e "\#^=== mon-nouveau-recoweb ${DOMAIN} START ===\$#,\#^=== mon-nouveau-recoweb ${DOMAIN} END ===\$#d" \
    "$SCAN_FILE" > "${SCAN_FILE}.tmp" || true
  mv "${SCAN_FILE}.tmp" "$SCAN_FILE"
fi

cat "$TMP_BLOCK" >> "$SCAN_FILE"
ok "Bloc mis à jour dans ${SCAN_FILE} pour le domaine ${DOMAIN}"

# Nettoyage
if [[ $DEBUG -eq 1 ]]; then
  info "DEBUG : aucun nettoyage des fichiers /tmp effectué."
  ls -1 /tmp/mon-nouveau-recoweb_"${DOMAIN//\//_}"_* 2>/dev/null || true
else
  rm -f /tmp/mon-nouveau-recoweb_"${DOMAIN//\//_}"_* 2>/dev/null || true
fi

exit 0
